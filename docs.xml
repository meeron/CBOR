<docs>
<doc name="T:PeterO.BigInteger">
<summary>
            <para><b>This class is largely obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.EInteger</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET), or <c>com.upokecenter.numbers.EInteger</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).  This new class can be used in the <c>CBORObject.FromObject(Object)</c>
            method (by including the new library in your code, among other things), but this version of the CBOR library doesn't
            include any methods that explicitly take an <c>EInteger</c> as a parameter
            or return value.</b></para>
            An arbitrary-precision integer.
            <para><b>Thread safety:</b>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same value are interchangeable, but they should be
            compared using the "Equals" method rather than the "==" operator.</para>
            </summary>
            ///
</doc>
<doc name="M:PeterO.BigInteger.Abs(PeterO.BigInteger)">
<summary>Gets this integer's absolute value.</summary>
            <param name='thisValue'>Another arbitrary-precision
            integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='thisValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.And(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Does an AND operation between two arbitrary-precision
            integer values.</summary>
            <param name='a'>The first arbitrary-precision integer.</param>
            <param name='b'>The second arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='a'/> or <paramref name='b'/> is null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a two's
            complement representation for the purposes of this
            operator.</remarks>
</doc>
<doc name="M:PeterO.BigInteger.CompareTo(PeterO.BigInteger)">
<summary>Compares an arbitrary-precision integer with this
            instance.</summary>
            <param name='other'>The parameter <paramref name='other'/> is not
            documented yet.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
</doc>
<doc name="M:PeterO.BigInteger.DivRem(PeterO.BigInteger,PeterO.BigInteger,PeterO.BigInteger@)">
<summary>Returns the quotient and remainder of two arbitrary-precision integers.</summary>
            <param name='dividend'>Big integer to be divided.</param>
            <param name='divisor'>The number to divide by.</param>
            <param name='remainder'>An integer reference where the remainder will be set.</param>
            <returns>An array of two big integers: the first is the quotient,
            and the second is the remainder.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='dividend'/> or <paramref name='divisor'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.Equals(PeterO.BigInteger)">
<summary>Returns whether this number's value is equal to another number's value.</summary>
            <param name='other'>An arbitrary-precision integer.</param>
            <returns><c>true</c> if this number's value is equal to another number's value; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.Equals(System.Object)">
<inheritdoc/>
            <summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>An arbitrary object.</param>
            <returns><c>true</c> if this object and another object are equal;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.GetBits(System.Int32,System.Int32)">
<summary>Gets a series of bits from the two's complement representation
of this number's value.</summary>
            <param name='index'>Zero-based index of the first bit to retrieve.</param>
            <param name='numberBits'>The number of bits to retrieve, from 0 to 64.</param>
            <returns>A 64-bit signed integer containing the bits retrieved.
            The least significant bit is first.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='numberBits'/> is less than 0 or greater than 64.</exception>
</doc>
<doc name="M:PeterO.BigInteger.GetHashCode">
<summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer.</returns>
</doc>
<doc name="M:PeterO.BigInteger.GreatestCommonDivisor(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Finds the greatest common divisor/greatest common factor (GCD/GCF) of two big integers.</summary>
            <param name='bigintFirst'>The first operand.</param>
            <param name='bigintSecond'>The second operand.</param>
            <returns>The greatest common divisor.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintFirst'/> is null.</exception>
</doc>
<doc name="P:PeterO.BigInteger.IsEven">
<summary>Gets a value indicating whether this value is
            even.</summary>
            <value><c>true</c> if this value is even; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.BigInteger.IsPowerOfTwo">
<summary>Gets a value indicating whether this object&#x27;s value
            is a power of two. (NOTE: This version allows negative numbers
            to be powers of two. In the EInteger version, only positive
            numbers will be considered powers of two.).</summary>
            <value><c>true</c> if this object&apos;s value is a power of two;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.BigInteger.IsZero">
<summary>Gets a value indicating whether this value is 0.</summary>
            <value><c>true</c> if this value is 0; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.BigInteger.ModPow(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Calculates the remainder when an arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary>
            <param name='pow'>Another arbitrary-precision integer.</param>
            <param name='mod'>An arbitrary-precision integer. (3).</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='pow'/> or <paramref name='mod'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.ModPow(PeterO.BigInteger,PeterO.BigInteger,PeterO.BigInteger)">
<summary>Calculates the remainder when an arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary><param name='bigintValue'>The number to raise to a power.</param><param name='pow'>The exponent to raise the number to.</param><param name='mod'>The modulus.</param><returns>The value ( <paramref name='bigintValue'/> ^ <paramref name='pow'/> )% <paramref name='mod'/>.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.Not(PeterO.BigInteger)">
<summary>Returns an arbitrary-precision integer with every bit
            flipped.</summary>
            <param name='valueA'>Another arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='valueA'/> is null.</exception>
</doc>
<doc name="F:PeterO.BigInteger.ONE">
<summary>BigInteger for the number one.</summary>
</doc>
<doc name="P:PeterO.BigInteger.One">
<summary>Gets the arbitrary-precision integer for one.</summary>
            <value>The arbitrary-precision integer for one.</value>
</doc>
<doc name="M:PeterO.BigInteger.Or(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Does an OR operation between two arbitrary-precision
            integer instances.</summary>
            <param name='first'>Another arbitrary-precision integer.</param>
            <param name='second'>An arbitrary-precision integer. (3).</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
            <remarks>Each arbitrary-precision integer is treated as a two's
            complement representation for the purposes of this
            operator.</remarks>
</doc>
<doc name="M:PeterO.BigInteger.Pow(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Returns this number raised to a power.</summary><param name='bigValue'>
            The value to raise to an exponent.</param><param name='power'>The exponent.</param><returns>The result. Returns 1 if <paramref name='power'/> is
            0.</returns>
</doc>
<doc name="M:PeterO.BigInteger.Pow(PeterO.BigInteger,System.Int32)">
<summary>Returns this number raised to a power.</summary><param name='bigValue'>The value to raise to an exponent.</param>
            <param name='power'>The exponent.</param><returns>The result. Returns 1 if <paramref name='power'/> is
            0.</returns>
</doc>
<doc name="M:PeterO.BigInteger.PowBigIntVar(PeterO.BigInteger)">
<summary>Raises a big integer to a power, which is given as another
            big integer.</summary>
            <param name='power'>The exponent to raise to.</param>
            <returns>The result. Returns 1 if <paramref name='power'/> is
            0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='power'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='power'/> is less than 0.</exception>
</doc>
<doc name="P:PeterO.BigInteger.Sign">
<summary>Gets the sign of this object's value.</summary>
            <value>0 if this value is zero; -1 if this value is negative, or 1
            if this value is positive.</value>
</doc>
<doc name="F:PeterO.BigInteger.TEN">
<summary>BigInteger for the number ten.</summary>
</doc>
<doc name="M:PeterO.BigInteger.ToByteArray">
<summary>Returns a byte array of this integer&#x27;s value. The byte
            array will take the form of the number's two's-complement
            representation, using the fewest bytes necessary to store its
            value unambiguously. If this value is negative, the bits that
            appear beyond the most significant bit of the number will be all
            ones.  The resulting byte array can be passed to the <c>FromBytes()</c>
            method (with the same byte order) to reconstruct this integer's value.
            The byte order used will be little-endian.</summary>
                       <returns>A byte array. If this value is 0, returns a byte array
            with the single element 0.</returns>
</doc>
<doc name="M:PeterO.BigInteger.ToString">
<summary>Converts this object to a text string in base
            10.</summary>
            <returns>A string representation of this object. If negative, the
            string will begin with a minus sign ("-", U+002D). The string will
            use the basic digits 0 to 9 (U+0030 to U+0039).</returns>
</doc>
<doc name="M:PeterO.BigInteger.Xor(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Finds the exclusive "or" of two arbitrary-precision
            integer objects.
            <para>Each arbitrary-precision integer is treated as a two's
            complement representation for the purposes of this
            operator.</para></summary>
            <param name='a'>The first arbitrary-precision integer.</param>
            <param name='b'>The second arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer in which each bit is set if
            it's set in one input integer but not the other.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='a'/> or <paramref name='b'/> is null.</exception>
</doc>
<doc name="F:PeterO.BigInteger.ZERO">
<summary>BigInteger for the number zero.</summary>
</doc>
<doc name="P:PeterO.BigInteger.Zero">
<summary>Gets the arbitrary-precision integer for zero.</summary>
            <value>The arbitrary-precision integer for zero.</value>
</doc>
<doc name="M:PeterO.BigInteger.abs">
<summary>Returns the absolute value of this object's
            value.</summary>
            <returns>This object's value with the sign removed.</returns>
</doc>
<doc name="M:PeterO.BigInteger.add(PeterO.BigInteger)">
<summary>Adds this object and another object.</summary>
            <param name='bigintAugend'>Another arbitrary-precision
            integer.</param>
            <returns>The sum of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintAugend'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.bitLength">
<summary>Finds the minimum number of bits needed to represent this
            object&#x27;s value, except for its sign. If the value is negative,
            finds the number of bits in a value equal to this object's absolute
            value minus 1.</summary>
            <returns>The number of bits in this object's value. Returns 0 if
            this object's value is 0 or negative 1.</returns>
</doc>
<doc name="M:PeterO.BigInteger.canFitInInt">
<summary>Returns whether this object's value can fit in a 32-bit
            signed integer.</summary>
            <returns><c>true</c> if this object's value is MinValue or greater, and
            MaxValue or less; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.divide(PeterO.BigInteger)">
<summary>Divides this instance by the value of an
            arbitrary-precision integer. The result is rounded down (the
            fractional part is discarded). Except if the result is 0, it will
            be negative if this object is positive and the other is negative,
            or vice versa, and will be positive if both are positive or both
            are negative.</summary>
            <param name='bigintDivisor'>Another arbitrary-precision
            integer.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='T:System.DivideByZeroException'>The divisor is
            zero.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintDivisor'/> is null.</exception>
            <exception cref='T:System.DivideByZeroException'>Attempted to
            divide by zero.</exception>
</doc>
<doc name="M:PeterO.BigInteger.divideAndRemainder(PeterO.BigInteger)">
<summary>Divides this object by another big integer and returns the
            quotient and remainder.</summary>
            <param name='divisor'>An arbitrary-precision integer.</param>
            <returns>An array with two big integers: the first is the quotient,
            and the second is the remainder.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
            <exception cref='T:System.DivideByZeroException'>The parameter
            <paramref name='divisor'/> is 0.</exception>
            <exception cref='T:System.DivideByZeroException'>Attempted to
            divide by zero.</exception>
</doc>
<doc name="M:PeterO.BigInteger.fromByteArray(System.Byte[],System.Boolean)">
<summary>Initializes an arbitrary-precision integer from an array
            of bytes.</summary>
            <param name='bytes'>A byte array.</param>
            <param name='littleEndian'>A Boolean object.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bytes'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.fromBytes(System.Byte[],System.Boolean)">
<summary>Initializes an arbitrary-precision integer from an array
            of bytes.</summary>
            <param name='bytes'>A byte array consisting of the two's-complement integer representation of the arbitrary-precision integer to create.
            The last byte contains the lowest 8-bits, the next-to-last contains the next lowest 8 bits, and so on. To encode negative numbers, take the absolute value of the number, subtract by 1, encode the number into bytes, XOR each byte, and if the most-significant bit of the first byte isn't set, add an additional byte at the start with the value 255.  For little-endian, the byte order is reversed from the byte order just discussed.</param>
            <param name='littleEndian'>If true, the byte order is little-endian,
            or least-significant-byte first.  If false, the byte order is big-endian,
            or most-significant-byte first.</param>
            <returns>An arbitrary-precision integer.  Returns 0 if the byte
            array's length is 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bytes'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.fromRadixString(System.String,System.Int32)">
<summary>Converts a string to an arbitrary-precision
            integer.</summary>
            <param name='str'>A text string. The string must contain only
            characters allowed by the given radix, except that it may start
            with a minus sign ("-", U+002D) to indicate a negative number. The
            string is not allowed to contain white space characters, including
            spaces.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039)
            and then the basic letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='radix'/> is less than 2 or greater than
            36.</exception>
            <exception cref='T:System.FormatException'>The string is empty or
            in an invalid format.</exception>
            <example>
            The following example (C#) converts a number in the
            form of a hex string to a big integer.
            <code>
            public static arbitrary-precision integer HexToBigInteger(string
            hexString) {
            // Parse the hexadecimal string as a big integer. Will
            // throw a FormatException if the parsing fails
            var bigInteger = arbitrary-precision
            integer.fromRadixString(hexString, 16);
            // Optional: Check if the parsed integer is negative
            if (bigInteger.Sign &lt; 0) {
            throw new FormatException("negative hex string");
            }
            return bigInteger;
            }
            </code>
            </example>
</doc>
<doc name="M:PeterO.BigInteger.fromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)">
<summary>Converts a portion of a string to an arbitrary-precision
            integer in a given radix.</summary>
            <param name='str'>A text string. The desired portion of the string
            must contain only characters allowed by the given radix, except
            that it may start with a minus sign ("-", U+002D) to indicate a
            negative number. The desired portion is not allowed to contain
            white space characters, including spaces.</param>
            <param name='radix'>A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039)
            and then the basic letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</param>
            <param name='index'>The index of the string that starts the string
            portion.</param>
            <param name='endIndex'>The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='index'/> is less than 0, <paramref name='endIndex'/> is less than 0, or either is greater than the
            string's length, or <paramref name='endIndex'/> is less than
            <paramref name='index'/>.</exception>
            <exception cref='T:System.FormatException'>The string portion is
            empty or in an invalid format.</exception>
</doc>
<doc name="M:PeterO.BigInteger.fromString(System.String)">
<summary>Converts a string to an arbitrary-precision
            integer.</summary>
            <param name='str'>A text string. The string must contain only basic
            digits 0 to 9 (U+0030 to U+0039), except that it may start with
            a minus sign ("-", U+002D) to indicate a negative number. The
            string is not allowed to contain white space characters, including
            spaces.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is in an invalid format.</exception>
</doc>
<doc name="M:PeterO.BigInteger.fromSubstring(System.String,System.Int32,System.Int32)">
<summary>Converts a portion of a string to an arbitrary-precision
            integer.</summary>
            <param name='str'>A text string. The desired portion of the string
            must contain only basic digits 0 to 9 (U+0030 to U+0039),
            except that it may start with a minus sign ("-", U+002D) to
            indicate a negative number. The desired portion is not allowed to
            contain white space characters, including spaces.</param>
            <param name='index'>The index of the string that starts the string
            portion.</param>
            <param name='endIndex'>The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param>
            <returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='index'/> is less than 0, <paramref name='endIndex'/> is less than 0, or either is greater than the
            string's length, or <paramref name='endIndex'/> is less than
            <paramref name='index'/>.</exception>
            <exception cref='T:System.FormatException'>The string portion is
            empty or in an invalid format.</exception>
</doc>
<doc name="M:PeterO.BigInteger.gcd(PeterO.BigInteger)">
<summary>Returns the greatest common divisor of two integers. The
            greatest common divisor (GCD) is also known as the greatest common
            factor (GCF).</summary>
            <param name='bigintSecond'>Another arbitrary-precision
            integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintSecond'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.getDigitCount">
<summary>Finds the number of decimal digits this number
            has.</summary>
            <returns>The number of decimal digits. Returns 1 if this object' s
            value is 0.</returns>
</doc>
<doc name="M:PeterO.BigInteger.getLowBit">
<summary>Gets the lowest set bit in this number's absolute
            value.</summary>
            <returns>The lowest bit set in the number, starting at 0. Returns 0
            if this value is 0 or odd. (NOTE: In future versions, may return -1
            instead if this value is 0.).</returns>
</doc>
<doc name="M:PeterO.BigInteger.getLowestSetBit">
<summary>See <c>getLowBit()</c></summary>
            <returns>See getLowBit().</returns>
</doc>
<doc name="M:PeterO.BigInteger.getUnsignedBitLength">
<summary>Finds the minimum number of bits needed to represent this
            object&#x27;s absolute value.</summary>
            <returns>The number of bits in this object's value. Returns 0 if
            this object's value is 0, and returns 1 if the value is negative
            1.</returns>
</doc>
<doc name="M:PeterO.BigInteger.intValue">
<summary>Converts this object's value to a 32-bit signed
            integer.</summary>
            <returns>A 32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 32-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.intValueChecked">
<summary>Converts this object's value to a 32-bit signed
            integer.</summary>
            <returns>A 32-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 32-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.intValueUnchecked">
<summary>Converts this object's value to a 32-bit signed integer.
            If the value can't fit in a 32-bit integer, returns the lower 32
            bits of this object's two's complement representation (in which
            case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 32-bit signed integer.</returns>
</doc>
<doc name="M:PeterO.BigInteger.longValue">
<summary>Converts this object's value to a 64-bit signed
            integer.</summary>
            <returns>A 64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 64-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.longValueChecked">
<summary>Converts this object's value to a 64-bit signed integer,
            throwing an exception if it can't fit.</summary>
            <returns>A 64-bit signed integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 64-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.longValueUnchecked">
<summary>Converts this object's value to a 64-bit signed integer.
            If the value can't fit in a 64-bit integer, returns the lower 64
            bits of this object's two's complement representation (in which
            case the return value might have a different sign than this
            object's value).</summary>
            <returns>A 64-bit signed integer.</returns>
</doc>
<doc name="M:PeterO.BigInteger.mod(PeterO.BigInteger)">
<summary>Finds the modulus remainder that results when this
            instance is divided by the value of an arbitrary-precision integer.
            The modulus remainder is the same as the normal remainder if the
            normal remainder is positive, and equals divisor plus normal
            remainder if the normal remainder is negative.</summary>
            <param name='divisor'>A divisor greater than 0 (the
            modulus).</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArithmeticException'>The parameter
            <paramref name='divisor'/> is negative.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.multiply(PeterO.BigInteger)">
<summary>Multiplies this instance by the value of an
            arbitrary-precision integer object.</summary>
            <param name='bigintMult'>Another arbitrary-precision
            integer.</param>
            <returns>The product of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintMult'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.negate">
<summary>Gets the value of this object with the sign
            reversed.</summary>
            <returns>This object's value with the sign reversed.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_Addition(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Adds an arbitrary-precision integer and an
            arbitrary-precision integer object.</summary>
            <param name='bthis'>The parameter <paramref name='bthis'/> is not
            documented yet.</param>
            <param name='augend'>The parameter <paramref name='augend'/> is not
            documented yet.</param>
            <returns>The sum of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bthis'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_Division(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Divides an arbitrary-precision integer by the value of an
            arbitrary-precision integer object.</summary><param name='dividend'>The number that will be divided by the divisor.</param><param name='divisor'>The number to divide by.</param><returns>The quotient of the two objects.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='dividend'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_Explicit(PeterO.BigInteger)~System.Int32">
<summary>Converts the value of an arbitrary-precision integer to a
            32-bit signed integer.</summary>
            <param name='bigValue'>An arbitrary-precision integer.</param>
            <returns>A 32-bit signed integer with the same value as the
            arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 32-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_Explicit(PeterO.BigInteger)~System.Int64">
<summary>Converts the value of an arbitrary-precision integer to a
            64-bit signed integer.</summary>
            <param name='bigValue'>An arbitrary-precision integer.</param>
            <returns>A 64-bit signed integer with the same value as the
            arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            too big to fit a 64-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_GreaterThan(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Determines whether an arbitrary-precision integer is
            greater than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is greater than
            <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_GreaterThanOrEqual(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Determines whether an arbitrary-precision integer value is
            greater than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is at least <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_Implicit(System.Int32)~PeterO.BigInteger">
<summary>Converts the value of a 32-bit signed integer to
            arbitrary-precision integer.</summary>
            <param name='smallValue'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision integer with the same value as the
            Int32 object.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_Implicit(System.Int64)~PeterO.BigInteger">
<summary>Converts the value of a 64-bit signed integer to
            arbitrary-precision integer.</summary>
            <param name='bigValue'>A 64-bit signed integer.</param>
            <returns>An arbitrary-precision integer with the same value as the
            Int64 object.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_LeftShift(PeterO.BigInteger,System.Int32)">
<summary>Returns an arbitrary-precision integer with the bits shifted to the left.</summary>
            <param name='bthis'>An arbitrary-precision integer whose value will be shifted.</param>
            <param name='bitCount'>The number of bits to shift left.
            If this number is negative, shifts right instead.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bthis'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_LessThan(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Determines whether an arbitrary-precision integer is less
            than another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is less than
            <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_LessThanOrEqual(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Determines whether an arbitrary-precision integer is less
            than or equal to another arbitrary-precision integer.</summary>
            <param name='thisValue'>The first arbitrary-precision
            integer.</param>
            <param name='otherValue'>The second arbitrary-precision
            integer.</param>
            <returns><c>true</c> if <paramref name='thisValue'/> is up to <paramref name='otherValue'/> ; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.op_Modulus(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Finds the remainder that results when an
            arbitrary-precision integer is divided by the value of an
            arbitrary-precision integer.</summary><param name='dividend'>The number that will be divided by the divisor.</param><param name='divisor'>The number to divide by.</param><returns>The remainder of the two numbers.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='dividend'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_Multiply(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Multiplies an arbitrary-precision integer by the value of
            an arbitrary-precision integer.</summary><param name='operand1'>The first operand.</param><param name='operand2'>The second operand.</param><returns>The product of the two numbers.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='operand1'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_RightShift(PeterO.BigInteger,System.Int32)">
<summary>Shifts the bits of an arbitrary-precision integer to the
            right.</summary>
            <param name='bthis'>Another arbitrary-precision integer.</param>
            <param name='smallValue'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bthis'/> is null.</exception>
            <remarks>For this operation, the arbitrary-precision integer is
            treated as a two's complement representation. Thus, for negative
            values, the arbitrary-precision integer is sign-extended.</remarks>
</doc>
<doc name="M:PeterO.BigInteger.op_Subtraction(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Subtracts two arbitrary-precision integer
            values.</summary>
            <param name='bthis'>An arbitrary-precision integer.</param>
            <param name='subtrahend'>Another arbitrary-precision
            integer.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bthis'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.op_UnaryNegation(PeterO.BigInteger)">
<summary>Negates an arbitrary-precision integer.</summary>
            <param name='bigValue'>Another arbitrary-precision integer.</param>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.pow(System.Int32)">
<summary>Raises a big integer to a power.</summary>
            <param name='powerSmall'>The exponent to raise to.</param>
            <returns>The result. Returns 1 if <paramref name='powerSmall'/> is
            0.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='powerSmall'/> is less than 0.</exception>
</doc>
<doc name="M:PeterO.BigInteger.remainder(PeterO.BigInteger)">
<summary>Finds the remainder that results when this instance is
            divided by the value of an arbitrary-precision integer. The
            remainder is the value that remains when the absolute value of this
            object is divided by the absolute value of the other object; the
            remainder has the same sign (positive or negative) as this
            object.</summary>
            <param name='divisor'>Another arbitrary-precision integer.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
            <exception cref='T:System.DivideByZeroException'>Attempted to
            divide by zero.</exception>
</doc>
<doc name="M:PeterO.BigInteger.shiftLeft(System.Int32)">
<summary>Returns a big integer with the bits shifted to the left by
            a number of bits. A value of 1 doubles this value, a value of 2
            multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so
            on.</summary>
            <param name='numberBits'>The number of bits to shift. Can be
            negative, in which case this is the same as shiftRight with the
            absolute value of numberBits.</param>
            <returns>An arbitrary-precision integer.</returns>
</doc>
<doc name="M:PeterO.BigInteger.shiftRight(System.Int32)">
<summary>Returns a big integer with the bits shifted to the right.
            For this operation, the arbitrary-precision integer is treated as a
            two's complement representation. Thus, for negative values, the
            arbitrary-precision integer is sign-extended.</summary>
            <param name='numberBits'>Number of bits to shift right.</param>
            <returns>An arbitrary-precision integer.</returns>
</doc>
<doc name="M:PeterO.BigInteger.sqrt">
<summary>Finds the square root of this instance&#x27;s value,
            rounded down.</summary>
            <returns>The square root of this object's value. Returns 0 if this
            value is 0 or less.</returns>
</doc>
<doc name="M:PeterO.BigInteger.sqrtWithRemainder">
<summary>Calculates the square root and the remainder.</summary>
            <returns>An array of two big integers: the first integer is the
            square root, and the second is the difference between this value
            and the square of the first integer. Returns two zeros if this
            value is 0 or less, or one and zero if this value equals
            1.</returns>
</doc>
<doc name="M:PeterO.BigInteger.subtract(PeterO.BigInteger)">
<summary>Subtracts an arbitrary-precision integer from this
            arbitrary-precision integer.</summary>
            <param name='subtrahend'>Another arbitrary-precision
            integer.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='subtrahend'/> is null.</exception>
</doc>
<doc name="M:PeterO.BigInteger.testBit(System.Int32)">
<summary>Returns whether a bit is set in the two's-complement
            representation of this object's value.</summary>
            <param name='index'>Zero based index of the bit to test. 0 means
            the least significant bit.</param>
            <returns><c>true</c> if a bit is set in the two's-complement
            representation of this object's value; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.BigInteger.toByteArray(System.Boolean)">
<summary>Returns a byte array of this object&#x27;s
            value.</summary>
            <param name='littleEndian'>A Boolean object.</param>
            <returns>A byte array.</returns>
</doc>
<doc name="M:PeterO.BigInteger.toBytes(System.Boolean)">
<summary>Returns a byte array of this object&#x27;s value. The byte
            array will take the form of the number's two' s-complement
            representation, using the fewest bytes necessary to represent its
            value unambiguously. If this value is negative, the bits that
            appear "before" the most significant bit of the number will be all
            ones.</summary>
            <param name='littleEndian'>If true, the least significant bits will
            appear first.</param>
            <returns>A byte array. If this value is 0, returns a byte array
            with the single element 0.</returns>
</doc>
<doc name="M:PeterO.BigInteger.toRadixString(System.Int32)">
<summary>Generates a string representing the value of this object,
            in the given radix.</summary>
            <param name='radix'>A radix from 2 through 36. For example, to
            generate a hexadecimal (base-16) string, specify 16. To generate a
            decimal (base-10) string, specify 10.</param>
            <returns>A string representing the value of this object. If this
            value is 0, returns "0". If negative, the string will begin with a
            hyphen/minus ("-"). Depending on the radix, the string will use the
            basic digits 0 to 9 (U+0030 to U+0039) and then the basic
            letters A to Z (U+0041 to U+005A). For example, 0-9 in radix
            10, and 0-9, then A-F in radix 16.</returns>
            <exception cref='T:System.ArgumentException'>The parameter "index"
            is less than 0, "endIndex" is less than 0, or either is greater
            than the string's length, or "endIndex" is less than "index" ; or
            radix is less than 2 or greater than 36.</exception>
</doc>
<doc name="M:PeterO.BigInteger.valueOf(System.Int64)">
<summary>Converts a 64-bit signed integer to a big
            integer.</summary>
            <param name='longerValue'>A 64-bit signed integer.</param>
            <returns>An arbitrary-precision integer with the same value as the
            64-bit number.</returns>
</doc>
<doc name="T:PeterO.Cbor.CBORDataUtilities">
<summary>Contains methods useful for reading and writing data, with
            a focus on CBOR.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)">
<summary>Parses a number whose format follows the JSON
            specification. See #ParseJSONNumber(String, integersOnly,
            parseOnly) for more information.</summary>
            <param name='str'>A string to parse.  The string is
            not allowed to contain white space characters, including
            spaces.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing
            fails, including if the string is null or empty.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 7159). Roughly speaking, a valid number consists
            of an optional minus sign, one or more basic digits (starting with
            1 to 9 unless the only digit is 0), an optional decimal point ("."
            , full stop) with one or more basic digits, and an optional letter
            E or e with an optional plus or minus sign and one or more basic
            digits (the exponent).</summary>
            <param name='str'>A string to parse.  The string is
            not allowed to contain white space characters, including
            spaces.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string.</param>
            <param name='positiveOnly'>If true, only positive numbers are
            allowed (the leading minus is disallowed).</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing
            fails, including if the string is null or empty.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 7159). Roughly speaking, a valid number consists
            of an optional minus sign, one or more basic digits (starting with
            1 to 9 unless the only digit is 0), an optional decimal point ("."
            , full stop) with one or more basic digits, and an optional letter
            E or e with an optional plus or minus sign and one or more basic
            digits (the exponent).</summary>
            <param name='str'>A string to parse.  The string is
            not allowed to contain white space characters, including
            spaces.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string.</param>
            <param name='positiveOnly'>If true, only positive numbers are
            allowed (the leading minus is disallowed).</param>
            <param name='preserveNegativeZero'>If true, returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0").  Otherwise, returns negative zero in this case.</param>
            <returns>A CBOR object that represents the parsed number.  Returns null if the parsing
            fails, including if the string is null or empty.</returns>
</doc>
<doc name="T:PeterO.Cbor.CBOREncodeOptions">
<summary>Specifies options for encoding and decoding CBOR
            objects.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.And(PeterO.Cbor.CBOREncodeOptions)">
<summary>Returns an options object whose flags are shared by this
            and another options object.</summary>
            <param name='o'>Another CBOREncodeOptions object.</param>
            <returns>A CBOREncodeOptions object.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.NoDuplicateKeys">
<summary>Disallow duplicate keys when reading CBOR objects from a
            data stream. Used only when decoding CBOR objects. Value:
            2.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.NoIndefLengthStrings">
<summary>Always encode strings with a definite-length encoding.
            Used only when encoding CBOR objects. Value: 1.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.None">
<summary>No special options for encoding/decoding. Value:
            0.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.Or(PeterO.Cbor.CBOREncodeOptions)">
<summary>Combines the flags of this options object with another
            options object.</summary>
            <param name='o'>Another CBOREncodeOptions object.</param>
            <returns>A CBOREncodeOptions object.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.Value">
<summary>Gets this options object's value.</summary>
            <value>This options object&apos;s value.</value>
</doc>
<doc name="T:PeterO.Cbor.CBORException">
<summary>Exception thrown for errors involving CBOR data.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor">
<summary>Initializes a new instance of the <see cref='T:PeterO.Cbor.CBORException'/> class.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor(System.String)">
<summary>Initializes a new instance of the <see cref='T:PeterO.Cbor.CBORException'/> class.</summary>
            <param name='message'>A text string.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor(System.String,System.Exception)">
<summary>Initializes a new instance of the <see cref='T:PeterO.Cbor.CBORException'/> class. Uses the given message and inner
            exception.</summary>
            <param name='message'>A text string.</param>
            <param name='innerException'>An Exception object.</param>
</doc>
<doc name="T:PeterO.Cbor.CBORObject">
<summary>Represents an object in Concise Binary Object
            Representation (CBOR) and contains methods for reading and writing
            CBOR data. CBOR is defined in RFC 7049.
            <para><b>Converting CBOR objects</b></para>
            <para>There are many ways to get a CBOR object, including from
            bytes, objects, streams and JSON, as described below.</para>
            <para><b>To and from byte arrays:</b> The CBORObject.DecodeToBytes
            method converts a byte array in CBOR format to a CBOR object. The
            EncodeToBytes method converts a CBOR object to its corresponding
            byte array in CBOR format.</para>
            <para><b>To and from data streams:</b> The CBORObject.Write methods
            write many kinds of objects to a data stream, including numbers,
            CBOR objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a data
            stream.</para>
            <para><b>To and from other objects:</b> The CBORObject.FromObject
            method converts many kinds of objects to a CBOR object, including
            numbers, strings, and arrays and maps of numbers and strings.
            Methods like AsDouble, AsByte, and AsString convert a CBOR object
            to different types of object.</para>
            <para><b>To and from JSON:</b> This class also doubles as a reader
            and writer of JavaScript Object Notation (JSON). The
            CBORObject.FromJSONString method converts JSON to a CBOR object,
            and the ToJSONString method converts a CBOR object to a JSON
            string.</para>
            <para>In addition, the CBORObject.WriteJSON method writes many
            kinds of objects as JSON to a data stream, including numbers, CBOR
            objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a JSON data
            stream.</para>
            <para><b>Comparison Considerations:</b></para>
            <para>Instances of CBORObject should not be compared for equality
            using the "==" operator; it's possible to create two CBOR objects
            with the same value but not the same reference. (The "==" operator
            only checks if each side of the operator is the same
            instance.)</para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method. This is important to consider especially
            if an application wants to compare numbers, since the CBOR number
            type supports numbers of different formats, such as big integers,
            rational numbers, and arbitrary-precision decimal numbers.</para>
            <para>Another consideration is that two values that are otherwise
            equal may have different tags. To strip the tags from a CBOR object
            before comparing, use the <c>Untag</c> method.</para>
            <para>To compare two numbers, the CompareToIgnoreTags or CompareTo
            method should be used. Which method to use depends on whether two
            equal values should still be considered equal if they have
            different tags.</para>
            <para>Although this class is inconsistent with the Equals method,
            it is safe to use CBORObject instances as hash keys as long as all
            of the keys are untagged text strings (which means GetTags returns
            an empty array and the Type property, or "getType()" in Java,
            returns TextString). This is because the natural ordering of these
            instances is consistent with the Equals method.</para>
            <para><b>Thread Safety:</b></para>
            <para>CBOR objects that are numbers, "simple values", and text
            strings are immutable (their values can't be changed), so they are
            inherently safe for use by multiple threads.</para>
            <para>CBOR objects that are arrays, maps, and byte strings are
            mutable, but this class doesn't attempt to synchronize reads and
            writes to those objects by multiple threads, so those objects are
            not thread safe without such synchronization.</para>
            <para>One kind of CBOR object is called a map, or a list of
            key-value pairs. Keys can be any kind of CBOR object, including
            numbers, strings, arrays, and maps. However, text strings are the
            most suitable to use as keys; other kinds of CBOR object are much
            better used as map values instead, keeping in mind that some of
            them are not thread safe without synchronizing reads and writes to
            them.</para>
            <para>To find the type of a CBOR object, call its Type property (or
            "getType()" in Java). The return value can be Number, Boolean,
            SimpleValue, or TextString for immutable CBOR objects, and Array,
            Map, or ByteString for mutable CBOR objects.</para>
            <para><b>Nesting Depth:</b></para>
            <para>The DecodeFromBytes and Read methods can only read objects
            with a limited maximum depth of arrays and maps nested within other
            arrays and maps. The code sets this maximum depth to 500 (allowing
            more than enough nesting for most purposes), but it's possible that
            stack overflows in some runtimes might lower the effective maximum
            nesting depth. When the nesting depth goes above 500, the
            DecodeFromBytes and Read methods throw a CBORException.</para>
            <para>The ReadJSON and FromJSONString methods currently have
            nesting depths of 1000.</para></summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Abs">
<summary>Gets this object's absolute value.</summary>
            <returns>This object's absolute without its negative
            sign.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(PeterO.Cbor.CBORObject)">
<summary>Adds a new object to the end of this array. (Used to throw
            ArgumentNullException on a null reference, but now converts the
            null reference to CBORObject.Null, for convenience with the Object
            overload of this method.).</summary>
            <param name='obj'>A CBOR object.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(System.Object)">
<summary>Converts an object to a CBOR object and adds it to the end
            of this array.</summary>
            <param name='obj'>A CBOR object.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception>
            <exception cref='T:System.ArgumentException'>The type of <paramref name='obj'/> is not supported.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(System.Object,System.Object)">
<summary>Adds a new key and its value to this CBOR map, or adds the
            value if the key doesn't exist.</summary>
            <param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> already exists in this map.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> or <paramref name='valueOb'/> has an
            unsupported type.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})">
<summary>Registers an object that converts objects of a given type
            to CBOR objects (called a CBOR converter).</summary>
            <param name='type'>A Type object specifying the type that the
            converter converts to CBOR objects.</param>
            <param name='converter'>An ICBORConverter object.</param>
            <typeparam name='T'>Must be the same as the "type"
            parameter.</typeparam>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='type'/> or <paramref name='converter'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.BigInteger,PeterO.Cbor.ICBORTag)">
<summary>Registers an object that validates CBOR objects with new
            tags.</summary>
            <param name='bigintTag'>An arbitrary-precision integer.</param>
            <param name='handler'>An ICBORTag object.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> or <paramref name='handler'/> is
            null.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than
            (2^64-1).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.Numbers.EInteger,PeterO.Cbor.ICBORTag)">
<summary>Registers an object that validates CBOR objects with new
            tags.</summary>
            <param name='bigintTag'>An arbitrary-precision integer.</param>
            <param name='handler'>An ICBORTag object.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> or <paramref name='handler'/> is
            null.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than
            (2^64-1).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Finds the sum of two CBOR numbers.</summary>
            <param name='first'>Another CBOR object.</param>
            <param name='second'>A CBORObject object. (3).</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsBigInteger">
<summary>Converts this object to an arbitrary-precision integer.
            Fractional values are truncated to an integer.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or not-a-number (NaN).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsBoolean">
<summary>Returns false if this object is False, Null, or Undefined;
            otherwise, true.</summary>
            <returns>False if this object is False, Null, or Undefined;
            otherwise, true.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsByte">
<summary>Converts this object to a byte (0 to 255). Floating point
            values are truncated to an integer.</summary>
            <returns>The closest byte-sized integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a byte (would be less than 0 or greater than
            255 when truncated to an integer).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDecimal">
<summary>Converts this object to a .NET decimal.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a .NET decimal.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDouble">
<summary>Converts this object to a 64-bit floating point
            number.</summary>
            <returns>The closest 64-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsExtendedDecimal">
<summary>Converts this object to a decimal number.</summary>
            <returns>A decimal number for this object's value. If this object
            is a rational number with a nonterminating decimal expansion,
            returns a decimal number rounded to 34 digits.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsExtendedFloat">
<summary>Converts this object to an arbitrary-precision binary
            floating point number.</summary>
            <returns>An arbitrary-precision binary floating point number for
            this object's value. Note that if this object is a decimal number
            with a fractional part, the conversion may lose information
            depending on the number. If this object is a rational number with a
            nonterminating binary expansion, returns a binary floating-point
            number rounded to 113 bits.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsExtendedRational">
<summary>Converts this object to a rational number.</summary>
            <returns>A rational number for this object's value.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt16">
<summary>Converts this object to a 16-bit signed integer. Floating
            point values are truncated to an integer.</summary>
            <returns>The closest 16-bit signed integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a 16-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt32">
<summary>Converts this object to a 32-bit signed integer. Floating
            point values are truncated to an integer.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a 32-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt64">
<summary>Converts this object to a 64-bit signed integer. Floating
            point values are truncated to an integer.</summary>
            <returns>The closest 64-bit signed integer to this
            object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a 64-bit signed integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsSByte">
<summary>Converts this object to an 8-bit signed integer.</summary>
            <returns>An 8-bit signed integer.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsSingle">
<summary>Converts this object to a 32-bit floating point
            number.</summary>
            <returns>The closest 32-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this object's value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsString">
<summary>Gets the value of this object as a text string.</summary>
            <returns>Gets this object's string.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a string, including if this object is
            CBORObject.Null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt16">
<summary>Converts this object to a 16-bit unsigned integer. The
            return value will be truncated as necessary.</summary>
            <returns>A 16-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            outside the range of a 16-bit unsigned integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt32">
<summary>Converts this object to a 32-bit unsigned integer. The
            return value will be truncated as necessary.</summary>
            <returns>A 32-bit unsigned integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            outside the range of a 32-bit unsigned integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt64">
<summary>Converts this object to a 64-bit unsigned integer.
            Floating point values are truncated to an integer.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
            <exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a 64-bit unsigned integer.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInDouble">
<summary>Returns whether this object's value can be converted to a
            64-bit floating point number without loss of its numerical
            value.</summary>
            <returns>Whether this object's value can be converted to a 64-bit
            floating point number without loss of its numerical value. Returns
            true if this is a not-a-number value, even if the value's
            diagnostic information can' t fit in a 64-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInInt32">
<summary>Returns whether this object's value is an integral value,
            is -(2^31) or greater, and is less than 2^31.</summary>
            <returns><c>true</c> if this object's value is an integral value, is
            -(2^31) or greater, and is less than 2^31; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInInt64">
<summary>Returns whether this object's value is an integral value,
            is -(2^63) or greater, and is less than 2^63.</summary>
            <returns><c>true</c> if this object's value is an integral value, is
            -(2^63) or greater, and is less than 2^63; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInSingle">
<summary>Returns whether this object's value can be converted to a
            32-bit floating point number without loss of its numerical
            value.</summary>
            <returns>Whether this object's value can be converted to a 32-bit
            floating point number without loss of its numerical value. Returns
            true if this is a not-a-number value, even if the value's
            diagnostic information can' t fit in a 32-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt32">
<summary>Returns whether this object's value, truncated to an
            integer, would be -(2^31) or greater, and less than 2^31.</summary>
            <returns><c>true</c> if this object's value, truncated to an integer,
            would be -(2^31) or greater, and less than 2^31; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt64">
<summary>Returns whether this object's value, truncated to an
            integer, would be -(2^63) or greater, and less than 2^63.</summary>
            <returns><c>true</c> if this object's value, truncated to an integer,
            would be -(2^63) or greater, and less than 2^63; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CompareTo(PeterO.Cbor.CBORObject)">
<summary>Compares two CBOR objects.
            <para>In this implementation:</para>
            <list type=''>
            <item>The null pointer (null reference) is considered less than any
            other object.</item>
            <item>If either object is true, false, CBORObject.Null, or the
            undefined value, it is treated as less than the other value. If
            both objects have one of these four values, then undefined is less
            than CBORObject.Null, which is less than false, which is less than
            true.</item>
            <item>If both objects are numbers, their mathematical values are
            compared. Here, NaN (not-a-number) is considered greater than any
            number.</item>
            <item>If both objects are simple values other than true, false,
            CBORObject.Null, and the undefined value, the objects are compared
            according to their ordinal numbers.</item>
            <item>If both objects are arrays, each element is compared. If one
            array is shorter than the other and the other array begins with
            that array (for the purposes of comparison), the shorter array is
            considered less than the longer array.</item>
            <item>If both objects are strings, compares each string code-point
            by code-point, as though by the DataUtilities.CodePointCompare
            method.</item>
            <item>If both objects are maps, compares each map as though each
            were an array with the sorted keys of that map as the array's
            elements. If both maps have the same keys, their values are
            compared in the order of the sorted keys.</item>
            <item>If each object is a different type, then they are sorted by
            their type number, in the order given for the CBORType
            enumeration.</item>
            <item>If each object has different tags and both objects are
            otherwise equal under this method, each element is compared as
            though each were an array with that object's tags listed in order
            from outermost to innermost.</item></list>
            <para>This method is not consistent with the Equals
            method.</para></summary>
            <param name='other'>A value to compare with.</param>
            <returns>Less than 0, if this value is less than the other object;
            or 0, if both values are equal; or greater than 0, if this value is
            less than the other object or if the other object is
            null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.CompareToIgnoreTags(PeterO.Cbor.CBORObject)">
<summary>Compares this object and another CBOR object, ignoring the
            tags they have, if any. See the CompareTo method for more
            information on the comparison function.</summary>
            <param name='other'>A value to compare with.</param>
            <returns>Less than 0, if this value is less than the other object;
            or 0, if both values are equal; or greater than 0, if this value is
            less than the other object or if the other object is
            null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ContainsKey(PeterO.Cbor.CBORObject)">
<summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>An object that serves as the key.</param>
            <returns><c>true</c> if the given key is found, or false if the given key
            is not found or this object is not a map.</returns>
            <exception cref='T:System.ArgumentNullException'>Key is null (as
            opposed to CBORObject.Null).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ContainsKey(System.String)">
<summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>A string that serves as the key.</param>
            <returns><c>true</c> if the given key (as a CBOR object) is found, or
            false if the given key is not found or this object is not a
            map.</returns>
            <exception cref='T:System.ArgumentNullException'>Key is
            null.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.ConverterInfo.Converter">
<summary>Gets or sets the ICBORConverter object.</summary>
            <value>The ICBORConverter object.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.ConverterInfo.ToObject">
<summary>Gets or sets the converter's ToCBORObject
            method.</summary>
            <value>The converter&apos;s ToCBORObject method.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Count">
<summary>Gets the number of keys in this map, or the number of
            items in this array, or 0 if this item is neither an array nor a
            map.</summary>
            <value>The number of keys in this map, or the number of items in
            this array, or 0 if this item is neither an array nor a
            map.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[])">
<summary>Generates a CBOR object from an array of CBOR-encoded
            bytes.</summary>
            <param name='data'>A byte array.</param>
            <returns>A CBOR object corresponding to the data.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is
            empty.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='data'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">
<summary>Generates a CBOR object from an array of CBOR-encoded
            bytes.</summary>
            <param name='data'>A byte array.</param>
            <param name='options'>A CBOREncodeOptions object.</param>
            <returns>A CBOR object corresponding to the data.</returns>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is
            empty.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='data'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Divide(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='first'>A CBORObject object.</param>
            <param name='second'>Another CBOR object.</param>
            <returns>The quotient of the two objects.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.EncodeToBytes">
<summary>Gets the binary representation of this data
            item.</summary>
            <returns>A byte array in CBOR format.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)">
<summary>Gets the binary representation of this data
            item.</summary>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <returns>A byte array in CBOR format.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='options'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Equals(PeterO.Cbor.CBORObject)">
<summary>Compares the equality of two CBOR objects.</summary>
            <param name='other'>The object to compare.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Equals(System.Object)">
<summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>An arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.False">
<summary>Represents the value false.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String)">
<summary>Generates a CBOR object from a text string in JavaScript Object
            Notation (JSON) format.
            <para>If a JSON object has the same key, only the last given value
            will be used for each duplicated key.</para></summary>
            <param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.CBOREncodeOptions)">
<summary>Generates a CBOR object from a text string in JavaScript Object
            Notation (JSON) format.
            <para>By default, if a JSON object has the same key, only the last
            given value will be used for each duplicated key.</para></summary>
            <param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param>
            <param name='options'>A CBOREncodeOptions object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.BigInteger)">
<summary>Generates a CBOR object from an arbitrary-precision
            integer.</summary>
            <param name='bigintValue'>An arbitrary-precision value.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject)">
<summary>Generates a CBOR object from a CBOR object.</summary>
            <param name='value'>A CBOR object.</param>
            <returns>Same as.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject[])">
<summary>Generates a CBOR object from an array of CBOR
            objects.</summary>
            <param name='array'>An array of CBOR objects.</param>
            <returns>A CBOR object where each element of the given array is
            copied to a new array, or CBORObject.Null if the value is
            null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedDecimal)">
<summary>Generates a CBOR object from a decimal number.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param><returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedFloat)">
<summary>Generates a CBOR object from an arbitrary-precision binary
            floating-point number.</summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedRational)">
<summary>Generates a CBOR object from an arbitrary-precision binary
            floating-point number.</summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EDecimal)">
<summary>Generates a CBOR object from a decimal number.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EFloat)">
<summary>Generates a CBOR object from an arbitrary-precision binary
            floating-point number.</summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.ERational)">
<summary>Generates a CBOR object from a rational number.</summary>
            <param name='bigValue'>A rational number.</param>
            <returns>A CBOR number.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Boolean)">
<summary>Returns the CBOR true value or false value, depending on
            &#x22;value&#x22;.</summary>
            <param name='value'>Either True or False.</param>
            <returns>CBORObject.True if value is true; otherwise
            CBORObject.False.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte)">
<summary>Generates a CBOR object from a byte (0 to 255).</summary>
            <param name='value'>A Byte object.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])">
<summary>Generates a CBOR object from a byte array. The byte array
            is copied to a new byte array. (This method can't be used to decode
            CBOR data from a byte array; for that, use the DecodeFromBytes
            method instead.).</summary>
            <param name='bytes'>A byte array. Can be null.</param>
            <returns>A CBOR byte string object where each byte of the given
            byte array is copied to a new array, or CBORObject.Null if the
            value is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Char)">
<summary>Generates a CBOR string object from a Unicode
            character.</summary>
            <param name='value'>A char object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='value'/> is a surrogate code point.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Decimal)">
<summary>Converts a .NET decimal to a CBOR object.</summary>
            <param name='value'>A Decimal object.</param>
            <returns>A CBORObject object with the same value as the .NET
            decimal.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Double)">
<summary>Generates a CBOR object from a 64-bit floating-point
            number.</summary>
            <param name='value'>A 64-bit floating-point number.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int16)">
<summary>Generates a CBOR object from a 16-bit signed
            integer.</summary>
            <param name='value'>A 16-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32)">
<summary>Generates a CBOR object from a 32-bit signed
            integer.</summary>
            <param name='value'>A 32-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32[])">
<summary>Generates a CBOR object from an array of 32-bit
            integers.</summary>
            <param name='array'>An array of 32-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64)">
<summary>Generates a CBOR object from a 64-bit signed
            integer.</summary>
            <param name='value'>A 64-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64[])">
<summary>Generates a CBOR object from an array of 64-bit
            integers.</summary>
            <param name='array'>An array of 64-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Object)">
<summary>Generates a CBORObject from an arbitrary object. The
            following types are specially handled by this method: null;
            primitive types; string; CBORObject; 
            the <c>EDecimal</c>, <c>EFloat</c>, <c>EInteger</c>, and <c>ERational</c>
            classes in the new <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a> library (in .NET) or the
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a> artifact (in Java);
            the legacy <c>ExtendedDecimal</c>, <c>ExtendedFloat</c>, 
            <c>ExtendedInteger</c>, and <c>ExtendedRational</c>
            classes in this library; arrays;
            enumerations ( <c>Enum</c> objects); and maps.
            <para>In the .NET version, if the object is a type not specially
            handled by this method, returns a CBOR map with the values of each
            of its read/write properties (or all properties in the case of an
            anonymous type). Properties are converted to their camel-case names
            (meaning if a name starts with A to Z, that letter is lower-cased).
            If the property name begins with the word "Is", that word is
            deleted from the name. Also, .NET <c>Enum</c> objects will be
            converted to their integer values, and a multidimensional array is
            converted to an array of arrays.</para>
            <para>In the Java version, if the object is a type not specially
            handled by this method, this method checks the CBOR object for
            methods starting with the word "get" or "is" that take no
            parameters, and returns a CBOR map with one entry for each such
            method found. For each method found, the starting word "get" or
            "is" is deleted from its name, and the name is converted to camel
            case (meaning if a name starts with A to Z, that letter is
            lower-cased). Also, Java <c>Enum</c> objects will be converted to
            the result of their name method.</para>
            <para>If the input is a byte array, the byte array is copied to a
            new byte array. (This method can't be used to decode CBOR data from
            a byte array; for that, use the DecodeFromBytes method
            instead.).</para></summary>
            <param name='obj'>An arbitrary object.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.SByte)">
<summary>Converts a signed 8-bit integer to a CBOR
            object.</summary>
            <param name='value'>An 8-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Single)">
<summary>Generates a CBOR object from a 32-bit floating-point
            number.</summary>
            <param name='value'>A 32-bit floating-point number.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.String)">
<summary>Generates a CBOR object from a text string.</summary>
            <param name='strValue'>A string value. Can be null.</param>
            <returns>A CBOR object representing the string, or CBORObject.Null
            if stringValue is null.</returns>
            <exception cref='T:System.ArgumentException'>The string contains an
            unpaired surrogate code point.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt16)">
<summary>Converts a 16-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt32)">
<summary>Converts a 32-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt64)">
<summary>Converts a 64-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.BigInteger)">
<summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='valueOb'>An arbitrary object. If the tag number is 2
            or 3, this must be a byte string whose bytes represent an integer
            in little-endian byte order, and the value of the number is 1 minus
            the integer's value for tag 3. If the tag number is 4 or 5, this
            must be an array with two elements: the first must be an integer
            representing the exponent, and the second must be an integer
            representing a mantissa.</param>
            <param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object.</param>
            <returns>A CBOR object where the object <paramref name='valueOb'/>
            is converted to a CBOR object and given the tag <paramref name='bigintTag'/>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than 2^64-1,
            or <paramref name='valueOb'/> 's type is unsupported.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.Int32)">
<summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='valueObValue'>An arbitrary object. If the tag number
            is 2 or 3, this must be a byte string whose bytes represent an
            integer in little-endian byte order, and the value of the number is
            1 minus the integer's value for tag 3. If the tag number is 4 or 5,
            this must be an array with two elements: the first must be an
            integer representing the exponent, and the second must be an
            integer representing a mantissa.</param>
            <param name='smallTag'>A 32-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object.</param>
            <returns>A CBOR object where the object <paramref name='valueObValue'/> is converted to a CBOR object and given the
            tag <paramref name='smallTag'/>.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='smallTag'/> is less than 0 or <paramref name='valueObValue'/> 's type is unsupported.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.UInt64)">
<summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='o'>An arbitrary object.</param>
            <param name='tag'>A 64-bit unsigned integer.</param>
            <returns>A CBOR object where the object <paramref name='o'/> is
            converted to a CBOR object and given the tag <paramref name='tag'/>
            .</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Generates a CBOR object from an enumerable set of
            objects.</summary>
            <param name='value'>An object that implements the IEnumerable
            interface. In the .NET version, this can be the return value of an
            iterator or the result of a LINQ query.</param>
            <typeparam name='T'>A type convertible to CBORObject.</typeparam>
            <returns>A CBOR object where each element of the given enumerable
            object is converted to a CBOR object and copied to a new array, or
            CBORObject.Null if the value is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IList{``0})">
<summary>Generates a CBOR object from a list of objects.</summary>
            <param name='value'>An array of CBOR objects. Can be null.</param>
            <typeparam name='T'>A type convertible to CBORObject.</typeparam>
            <returns>A CBOR object where each element of the given array is
            converted to a CBOR object and copied to a new array, or
            CBORObject.Null if the value is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject``2(System.Collections.Generic.IDictionary{``0,``1})">
<summary>Generates a CBOR object from a map of objects.</summary>
            <param name='dic'>A map of CBOR objects.</param>
            <typeparam name='TKey'>A type convertible to CBORObject; the type
            of the keys.</typeparam>
            <typeparam name='TValue'>A type convertible to CBORObject; the type
            of the values.</typeparam>
            <returns>A CBOR object where each key and value of the given map is
            converted to a CBOR object and copied to a new map, or
            CBORObject.Null if <paramref name='dic'/> is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromSimpleValue(System.Int32)">
<summary>Creates a CBOR object from a simple value
            number.</summary>
            <param name='simpleValue'>A 32-bit signed integer.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='simpleValue'/> is less than 0, greater than 255, or
            from 24 through 31.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetByteString">
<summary>Gets the byte array used in this object, if this object is
            a byte string, without copying the data to a new one. This method's
            return value can be used to modify the array's contents. Note,
            though, that the array' s length can't be changed.</summary>
            <returns>A byte array.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a byte string.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetHashCode">
<summary>Calculates the hash code of this object.</summary>
            <returns>A 32-bit hash code.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetTags">
<summary>Gets a list of all tags, from outermost to
            innermost.</summary>
            <returns>An array of tags, or the empty string if this object is
            untagged.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasTag(PeterO.BigInteger)">
<summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='bigTagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>BigTagValue is
            null.</exception>
            <exception cref='T:System.ArgumentException'>BigTagValue is less
            than 0.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasTag(System.Int32)">
<summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='tagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentException'>TagValue is less than
            0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            "obj" is null.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.InnermostTag">
<summary>Gets the last defined tag for this CBOR data item, or -1
            if the item is untagged.</summary>
            <value>The last defined tag for this CBOR data item, or -1 if the
            item is untagged.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Insert(System.Int32,System.Object)">
<summary>Inserts an object at the specified position in this CBOR
            array.</summary>
            <param name='index'>Zero-based index to insert at.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='valueOb'/> has an unsupported type; or <paramref name='index'/> is not a valid index into this array.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsFalse">
<summary>Gets a value indicating whether this value is a CBOR false
            value.</summary>
            <value><c>true</c> if this value is a CBOR false value; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsFinite">
<summary>Gets a value indicating whether this CBOR object
            represents a finite number.</summary>
            <value><c>true</c> if this CBOR object represents a finite number;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsInfinity">
<summary>Gets a value indicating whether this CBOR object
            represents infinity.</summary>
            <returns><c>true</c> if this CBOR object represents infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsIntegral">
<summary>Gets a value indicating whether this object represents an
            integral number, that is, a number without a fractional part.
            Infinity and not-a-number are not considered integral.</summary>
            <value><c>true</c> if this object represents an integral number, that is,
            a number without a fractional part; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsNaN">
<summary>Gets a value indicating whether this CBOR object
            represents a not-a-number value (as opposed to whether this
            object&#x27;s type is not a number type).</summary>
            <returns><c>true</c> if this CBOR object represents a not-a-number value
            (as opposed to whether this object's type is not a number type);
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsNegative">
<summary>Gets a value indicating whether this object is a negative number.</summary>
            <value><c>true</c> if this object is a negative number; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsNegativeInfinity">
<summary>Gets a value indicating whether this CBOR object
            represents negative infinity.</summary>
            <returns><c>true</c> if this CBOR object represents negative infinity;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsNull">
<summary>Gets a value indicating whether this value is a CBOR null
            value.</summary>
            <value><c>true</c> if this value is a CBOR null value; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsPositiveInfinity">
<summary>Gets a value indicating whether this CBOR object
            represents positive infinity.</summary>
            <returns><c>true</c> if this CBOR object represents positive infinity;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsTagged">
<summary>Gets a value indicating whether this data item has at
            least one tag.</summary>
            <value><c>true</c> if this data item has at least one tag; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsTrue">
<summary>Gets a value indicating whether this value is a CBOR true
            value.</summary>
            <value><c>true</c> if this value is a CBOR true value; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsUndefined">
<summary>Gets a value indicating whether this value is a CBOR
            undefined value.</summary>
            <value><c>true</c> if this value is a CBOR undefined value; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsZero">
<summary>Gets a value indicating whether this object&#x27;s value
            equals 0.</summary>
            <value><c>true</c> if this object&apos;s value equals 0; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(PeterO.Cbor.CBORObject)">
<summary>Gets the value of a CBOR object in this map, using a CBOR
            object as the key.</summary>
            <param name='key'>Another CBOR object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The key is null
            (as opposed to CBORObject.Null); or the set method is called and
            the value is null.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(System.Int32)">
<summary>Gets the value of a CBOR object by integer index in this
            array.</summary>
            <param name='index'>Zero-based index of the element.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            "value" is null (as opposed to CBORObject.Null).</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(System.String)">
<summary>Gets the value of a CBOR object in this map, using a
            string as the key.</summary>
            <param name='key'>A key that points to the desired value.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The key is
            null.</exception>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Keys">
<summary>Gets a collection of the keys of this CBOR object in an
            undefined order.</summary>
            <value>A collection of the keys of this CBOR object.</value>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Multiplies two CBOR numbers.</summary>
            <param name='first'>A CBORObject object.</param>
            <param name='second'>Another CBOR object.</param>
            <returns>The product of the two numbers.</returns>
            <exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.NaN">
<summary>A not-a-number value.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Negate">
<summary>Gets this object's value with the sign reversed.</summary>
            <returns>The reversed-sign form of this number.</returns>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.NegativeInfinity">
<summary>The value negative infinity.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.NewArray">
<summary>Creates a new empty CBOR array.</summary>
            <returns>A new CBOR array.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.NewMap">
<summary>Creates a new empty CBOR map.</summary>
            <returns>A new CBOR map.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.Null">
<summary>Represents the value null.</summary>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.OutermostTag">
<summary>Gets the outermost tag for this CBOR data item, or -1 if
            the item is untagged.</summary>
            <value>The outermost tag for this CBOR data item, or -1 if the item
            is untagged.</value>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.PositiveInfinity">
<summary>The value positive infinity.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream)">
<summary>Reads an object in CBOR format from a data stream. This
            method will read from the stream until the end of the CBOR object
            is reached or an error occurs, whichever happens first.</summary>
            <param name='stream'>A readable data stream.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
<summary>Reads an object in CBOR format from a data stream. This
            method will read from the stream until the end of the CBOR object
            is reached or an error occurs, whichever happens first.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='options'>A CBOREncodeOptions object.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream)">
<summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can
            be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected
            by assuming that the first character read must be a byte-order mark
            or a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>If a JSON object has the same key, only the last given value
            will be used for each duplicated key.</para></summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
<summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can
            be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected
            by assuming that the first character read must be a byte-order mark
            or a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>By default, if a JSON object has the same key, only the last
            given value will be used for each duplicated key.</para></summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <param name='options'>A CBOREncodeOptions object.</param>
            <returns>A CBORObject object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Remainder(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBORObject object.</summary>
            <param name='first'>A CBORObject object.</param>
            <param name='second'>Another CBOR object.</param>
            <returns>The remainder of the two numbers.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Remove(PeterO.Cbor.CBORObject)">
<summary>If this object is an array, removes the first instance of
            the specified item from the array. If this object is a map, removes
            the item with the given key from the map.</summary>
            <param name='obj'>The item or key to remove.</param>
            <returns><c>true</c> if the item was removed; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='obj'/> is null (as opposed to
            CBORObject.Null).</exception>
            <exception cref='T:System.InvalidOperationException'>The object is
            not an array or map.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Set(System.Object,System.Object)">
<summary>Maps an object to a key in this CBOR map, or adds the
            value if the key doesn't exist.</summary>
            <param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> or <paramref name='valueOb'/> has an
            unsupported type.</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Sign">
<summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary>
            <value>This value&apos;s sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
            <exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including the special not-a-number value
            (NaN).</exception>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.SimpleValue">
<summary>Gets the simple value ID of this object, or -1 if this
            object is not a simple value (including if the value is a
            floating-point number).</summary>
            <value>The simple value ID of this object, or -1 if this object is
            not a simple value (including if the value is a floating-point
            number).</value>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Subtract(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Finds the difference between two CBOR number
            objects.</summary>
            <param name='first'>A CBORObject object.</param>
            <param name='second'>Another CBOR object.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToJSONString">
<summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format. This function works not only with arrays
            and maps, but also integers, strings, byte arrays, and other JSON
            data types. Notes:
            <list type=''>
            <item>If this object contains maps with non-string keys, the keys
            are converted to JSON strings before writing the map as a JSON
            string.</item>
            <item>If a number in the form of an arbitrary-precision binary float has a very high binary
            exponent, it will be converted to a double before being converted
            to a JSON string. (The resulting double could overflow to infinity,
            in which case the arbitrary-precision binary float is converted to null.)</item>
            <item>The string will not begin with a byte-order mark (U+FEFF);
            RFC 7159 (the JSON specification) forbids placing a byte-order mark
            at the beginning of a JSON string.</item>
            <item>Byte strings are converted to Base64 URL by default.</item>
            <item>Rational numbers will be converted to their exact form, if
            possible, otherwise to a high-precision approximation. (The
            resulting approximation could overflow to infinity, in which case
            the rational number is converted to null.)</item>
            <item>Simple values other than true and false will be converted to
            null. (This doesn't include floating-point numbers.)</item>
            <item>Infinity and not-a-number will be converted to
            null.</item></list></summary>
            <returns>A text string containing the converted object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToString">
<summary>Returns this CBOR object in string form. The format is
            intended to be human-readable, not machine-readable, and the format
            may change at any time.</summary>
            <returns>A text representation of this object.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.True">
<summary>Represents the value true.</summary>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Type">
<summary>Gets the general data type of this CBOR object.</summary>
            <value>The general data type of this CBOR object.</value>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.Undefined">
<summary>Represents the value undefined.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Untag">
<summary>Gets an object with the same value as this one but without
            the tags it has, if any. If this object is an array, map, or byte
            string, the data will not be copied to the returned object, so
            changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.UntagOne">
<summary>Gets an object with the same value as this one but without
            this object's outermost tag, if any. If this object is an array,
            map, or byte string, the data will not be copied to the returned
            object, so changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Values">
<summary>Gets a collection of the values of this CBOR object. If
            this object is a map, returns one value for each key in the map in
            an undefined order. If this is an array, returns all the values of
            the array in the order they are listed.</summary>
            <value>A collection of the values of this CBOR object.</value>
            <exception cref='T:System.InvalidOperationException'>This object is
            not a map or an array.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.BigInteger,System.IO.Stream)">
<summary>Writes a big integer in CBOR format to a data
            stream.</summary>
            <param name='bigint'>Big integer to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Cbor.CBORObject,System.IO.Stream)">
<summary>Writes a CBOR object to a CBOR data stream.</summary>
            <param name='value'>The value to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedDecimal,System.IO.Stream)">
<summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a decimal
            number.</item></list></summary>
            <param name='bignum'>The arbitrary-precision decimal number to write. Can be
            null.</param>
            <param name='stream'>Stream to write to.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedFloat,System.IO.Stream)">
<summary>Writes a binary floating-point number in CBOR format to a
            data stream as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a big
            float.</item></list></summary>
            <param name='bignum'>An arbitrary-precision binary float.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedRational,System.IO.Stream)">
<summary>Writes a rational number in CBOR format to a data
            stream.</summary>
            <param name='rational'>An arbitrary-precision rational
            number.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)">
<summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a decimal
            number.</item></list></summary>
            <param name='bignum'>The arbitrary-precision decimal number to write. Can be
            null.</param>
            <param name='stream'>Stream to write to.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)">
<summary>Writes a binary floating-point number in CBOR format to a
            data stream as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a big
            float.</item></list></summary>
            <param name='bignum'>An arbitrary-precision binary float.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)">
<summary>Writes a big integer in CBOR format to a data
            stream.</summary>
            <param name='bigint'>Big integer to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)">
<summary>Writes a rational number in CBOR format to a data
            stream.</summary>
            <param name='rational'>An arbitrary-precision rational
            number.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Boolean,System.IO.Stream)">
<summary>Writes a Boolean value in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Byte,System.IO.Stream)">
<summary>Writes a byte (0 to 255) in CBOR format to a data stream.
            If the value is less than 24, writes that byte. If the value is 25
            to 255, writes the byte 24, then this byte's value.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Char,System.IO.Stream)">
<summary>Writes a Unicode character as a string in CBOR format to a
            data stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='value'/> is a surrogate code point.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Double,System.IO.Stream)">
<summary>Writes a 64-bit floating-point number in CBOR format to a
            data stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int16,System.IO.Stream)">
<summary>Writes a 16-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int32,System.IO.Stream)">
<summary>Writes a 32-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int64,System.IO.Stream)">
<summary>Writes a 64-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream)">
<summary>Writes a CBOR object to a CBOR data stream. See the
            three-parameter Write method that takes a
            CBOREncodeOptions.</summary>
            <param name='objValue'>An arbitrary object.</param>
            <param name='stream'>A writable data stream.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
<summary>Writes an arbitrary object to a CBOR data stream.
            Currently, the following objects are supported:
            <list type=''>
            <item>Lists of CBORObject.</item>
            <item>Maps of CBORObject.</item>
            <item>Null.</item>
            <item>Byte arrays, which will always be written as definite-length
            byte strings.</item>
            <item>String objects, which will be written as indefinite-length
            text strings if their size exceeds a certain threshold (this
            behavior may change in future versions of this library).</item>
            <item>Any object accepted by the FromObject static
            methods.</item></list></summary>
            <param name='objValue'>The arbitrary object to be serialized. Can
            be null.</param>
            <param name='output'>A writable data stream.</param>
            <param name='options'>CBOR options for encoding the CBOR object to
            bytes.</param>
            <exception cref='T:System.ArgumentException'>The object's type is
            not supported.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='options'/> or <paramref name='output'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.SByte,System.IO.Stream)">
<summary>Writes an 8-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>An 8-bit signed integer.</param>
            <param name='stream'>A writable data stream.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Single,System.IO.Stream)">
<summary>Writes a 32-bit floating-point number in CBOR format to a
            data stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='s'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='s'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream)">
<summary>Writes a string in CBOR format to a data stream. The
            string will be encoded using indefinite-length encoding if its
            length exceeds a certain threshold (this behavior may change in
            future versions of this library).</summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
<summary>Writes a string in CBOR format to a data stream.</summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt16,System.IO.Stream)">
<summary>Writes a 16-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt32,System.IO.Stream)">
<summary>Writes a 32-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt64,System.IO.Stream)">
<summary>Writes a 64-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteJSON(System.Object,System.IO.Stream)">
<summary>Converts an arbitrary object to a string in JavaScript
            Object Notation (JSON) format, as in the ToJSONString method, and
            writes that string to a data stream in UTF-8.</summary>
            <param name='obj'>An arbitrary object.</param>
            <param name='outputStream'>A writable data stream.</param>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream)">
<summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='outputStream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)">
<summary>Writes this CBOR object to a data stream.</summary>
            <param name='stream'>A writable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">
<summary>Writes this CBOR object to a data stream.</summary>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="F:PeterO.Cbor.CBORObject.Zero">
<summary>Gets a CBOR object for the number zero.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Adds a CBORObject object and a CBORObject
            object.</summary>
            <param name='a'>A CBORObject object.</param>
            <param name='b'>Another CBORObject object.</param>
            <returns>The sum of the two objects.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Division(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='a'>A CBORObject object.</param>
            <param name='b'>Another CBORObject object.</param>
            <returns>The quotient of the two objects.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Modulus(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBORObject object.</summary>
            <param name='a'>A CBORObject object.</param>
            <param name='b'>Another CBORObject object.</param>
            <returns>The remainder of the two numbers.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Multiplies a CBORObject object by the value of a
            CBORObject object.</summary>
            <param name='a'>A CBORObject object.</param>
            <param name='b'>Another CBORObject object.</param>
            <returns>The product of the two numbers.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Subtraction(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">
<summary>Subtracts a CBORObject object from a CBORObject
            object.</summary>
            <param name='a'>A CBORObject object.</param>
            <param name='b'>Another CBORObject object.</param>
            <returns>The difference of the two objects.</returns>
</doc>
<doc name="T:PeterO.Cbor.CBORObjectMath">
<summary>Implements arithmetic operations with CBOR
            objects.</summary>
</doc>
<doc name="T:PeterO.Cbor.CBORTag3">
<summary>Implements CBOR tag 3.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTag37.ToCBORObject(System.Guid)">
<summary>Converts a UUID to a CBOR object.</summary>
            <param name='obj'>A UUID.</param>
            <returns>A CBORObject object.</returns>
</doc>
<doc name="T:PeterO.Cbor.CBORTagGenericString">
<summary>A generic CBOR tag class for strings.</summary>
</doc>
<doc name="T:PeterO.Cbor.CBORType">
<summary>Represents a type that a CBOR object can have.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.Array">
<summary>An array of CBOR objects.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.Boolean">
<summary>The simple values true and false.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.ByteString">
<summary>An array of bytes.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.Map">
<summary>A map of CBOR objects.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.Number">
<summary>A number of any kind, including integers, big integers,
            floating point numbers, and decimal numbers. The floating-point
            value Not-a-Number is also included in the Number type.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.SimpleValue">
<summary>A &#x22;simple value&#x22; other than floating point
            values, true, and false.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORType.TextString">
<summary>A text string.</summary>
</doc>
<doc name="T:PeterO.Cbor.CBORTypeFilter">
<summary>Specifies what kinds of CBOR objects a tag can be. This
            class is used when a CBOR object is being read from a data stream.
            This class cannot be inherited; this is a change in version 2.0
            from previous versions, where the class was inadvertently left
            inheritable.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.Any">
<summary>A filter that allows any CBOR object.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.ArrayIndexAllowed(System.Int32)">
<summary>Determines whether this type filter allows CBOR arrays and
            the given array index is allowed under this type filter.</summary>
            <param name='index'>An array index, starting from 0.</param>
            <returns><c>true</c> if this type filter allows CBOR arrays and the given
            array index is allowed under this type filter; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(PeterO.BigInteger)">
<summary>Returns whether an array's length is allowed under a
            filter.</summary>
            <param name='bigLength'>An arbitrary-precision integer.</param>
            <returns><c>true</c> if this filter allows CBOR arrays and an array's
            length is allowed under a filter; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigLength'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(PeterO.Numbers.EInteger)">
<summary>Returns whether an array's length is allowed under a
            filter.</summary>
            <param name='bigLength'>An arbitrary-precision integer.</param>
            <returns><c>true</c> if this filter allows CBOR arrays and an array's
            length is allowed under a filter; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigLength'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(System.Int32)">
<summary>Returns whether an array's length is allowed under this
            filter.</summary>
            <param name='length'>The length of a CBOR array.</param>
            <returns><c>true</c> if this filter allows CBOR arrays and an array's
            length is allowed under this filter; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(System.Int64)">
<summary>Returns whether an array's length is allowed under a
            filter.</summary>
            <param name='length'>The length of a CBOR array.</param>
            <returns><c>true</c> if this filter allows CBOR arrays and an array's
            length is allowed under a filter; otherwise, <c>false</c>.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.ByteString">
<summary>A filter that allows byte strings.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.GetSubFilter(System.Int32)">
<summary>Gets the type filter for this array filter by its index.</summary>
            <param name='index'>A zero-based index of the filter to retrieve.</param>
            <returns>Returns None if the index is out of range, or Any if this
            filter doesn't filter an array.  Returns the appropriate filter for the array index otherwise.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.GetSubFilter(System.Int64)">
<summary>Gets the type filter for this array filter by its index.</summary>
            <param name='index'>A zero-based index of the filter to retrieve.</param>
            <returns>Returns None if the index is out of range, or Any if this
            filter doesn't filter an array.  Returns the appropriate filter for the array index otherwise.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.MajorTypeMatches(System.Int32)">
<summary>Returns whether the given CBOR major type matches a major type
allowed by this filter.</summary>
            <param name='type'>A CBOR major type from 0 to 7.</param>
            <returns><c>true</c> if the given CBOR major type matches a major type
allowed by this filter; otherwise, <c>false</c>.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.NegativeInteger">
<summary>A filter that allows negative integers.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.NonFPSimpleValueAllowed">
<summary>Returns whether this filter allows simple values that are
            not floating-point numbers.</summary>
            <returns><c>true</c> if this filter allows simple values that are not
            floating-point numbers; otherwise, <c>false</c>.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.None">
<summary>A filter that allows no CBOR types.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.TagAllowed(PeterO.BigInteger)">
<summary>Gets a value indicating whether CBOR objects can have the
            given tag number.</summary>
            <param name='bigTag'>A tag number. Returns false if this is less
            than 0.</param>
            <returns><c>true</c> if CBOR objects can have the given tag number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigTag'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.TagAllowed(PeterO.Numbers.EInteger)">
<summary>Gets a value indicating whether CBOR objects can have the
            given tag number.</summary>
            <param name='bigTag'>A tag number. Returns false if this is less
            than 0.</param>
            <returns><c>true</c> if CBOR objects can have the given tag number;
            otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigTag'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.TagAllowed(System.Int32)">
<summary>Gets a value indicating whether CBOR objects can have the
            given tag number.</summary>
            <param name='tag'>A tag number. Returns false if this is less than
            0.</param>
            <returns><c>true</c> if CBOR objects can have the given tag number;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.TagAllowed(System.Int64)">
<summary>Gets a value indicating whether CBOR objects can have the
            given tag number.</summary>
            <param name='longTag'>A tag number. Returns false if this is less than
            0.</param>
            <returns><c>true</c> if CBOR objects can have the given tag number;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.TextString">
<summary>A filter that allows text strings.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORTypeFilter.UnsignedInteger">
<summary>A filter that allows unsigned integers.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithArrayAnyLength">
<summary>Copies this filter and includes arrays of any length in
            the new filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithArrayExactLength(System.Int32,PeterO.Cbor.CBORTypeFilter[])">
<summary>Copies this filter and includes CBOR arrays with an exact
            length to the new filter.</summary>
            <param name='arrayLength'>The desired maximum length of an
            array.</param>
            <param name='elements'>An array containing the allowed types for
            each element in the array. There must be at least as many elements
            here as given in the arrayLength parameter.</param>
            <returns>A CBORTypeFilter object.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            arrayLength is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            elements is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter elements
            has fewer elements than specified in arrayLength.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithArrayMinLength(System.Int32,PeterO.Cbor.CBORTypeFilter[])">
<summary>Copies this filter and includes CBOR arrays with at least
            a given length to the new filter.</summary>
            <param name='arrayLength'>The desired minimum length of an
            array.</param>
            <param name='elements'>An array containing the allowed types for
            each element in the array. There must be at least as many elements
            here as given in the arrayLength parameter.</param>
            <returns>A CBORTypeFilter object.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            arrayLength is less than 0.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            elements is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter elements
            has fewer elements than specified in arrayLength.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithByteString">
<summary>Copies this filter and includes byte strings in the new
            filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithFloatingPoint">
<summary>Copies this filter and includes floating-point numbers in
            the new filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithMap">
<summary>Copies this filter and includes maps in the new
            filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithNegativeInteger">
<summary>Copies this filter and includes negative integers in the
            new filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithTags(PeterO.BigInteger[])">
<summary>Copies this filter and includes a set of valid CBOR tags in the new filter.</summary>
            <param name='tags'>An array of the CBOR tags to add to the new filter.</param>
            <returns>A CBORTypeFilter object.</returns>
            <exception cref='T:System.ArgumentNullException'>One or more of
            the tags in the parameter "tags" is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithTags(System.Int32[])">
<summary>Copies this filter and includes a set of valid CBOR tags in the new filter.</summary>
            <param name='tags'>An array of the CBOR tags to add to the new filter.</param>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithTextString">
<summary>Copies this filter and includes text strings in the new
            filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORTypeFilter.WithUnsignedInteger">
<summary>Copies this filter and includes unsigned integers in the
            new filter.</summary>
            <returns>A CBORTypeFilter object.</returns>
</doc>
<doc name="T:PeterO.Cbor.CBORUtilities">
<summary>Contains utility methods that may have use outside of the
            CBORObject class.</summary>
</doc>
<doc name="T:PeterO.Cbor.CharacterReader">
<summary>A general-purpose character input for reading text from
            byte streams and text strings. When reading byte streams, this
            class supports the UTF-8 character encoding by default, but can be
            configured to support UTF-16 and UTF-32 as well.</summary>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.IO.Stream)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class;
            will read the stream as UTF-8, skip the byte-order mark (U+FEFF)
            if it appears first in the stream, and replace invalid byte sequences with replacement characters (U+FFFD).</summary>
            <param name='stream'>A readable data stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.IO.Stream,System.Int32)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class;
            will skip the byte-order mark (U+FEFF) if it appears first in the
            stream and replace invalid byte sequences with replacement
            characters (U+FFFD).</summary>
            <param name='stream'>A readable byte stream.</param>
            <param name='mode'>The method to use when detecting encodings other
            than UTF-8 in the byte stream. This usually involves checking
            whether the stream begins with a byte-order mark (BOM, U+FEFF) or
            a non-zero basic code point (NZB, U+0001 to U+007F) before
            reading the rest of the stream. This value can be one of the
            following:
            <list>
            <item>0: UTF-8 only.</item>
            <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.</item>
            <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8.
            (Tries to detect UTF-32 first.)</item>
            <item>3: Detect UTF-16 using BOM, otherwise UTF-8.</item>
            <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to
            detect UTF-32 first.)</item></list>.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class;
            will skip the byte-order mark (U+FEFF) if it appears first in the
            stream.</summary>
            <param name='stream'>A readable byte stream.</param>
            <param name='mode'>The method to use when detecting encodings other
            than UTF-8 in the byte stream. This usually involves checking
            whether the stream begins with a byte-order mark (BOM, U+FEFF) or
            a non-zero basic code point (NZB, U+0001 to U+007F) before
            reading the rest of the stream. This value can be one of the
            following:
            <list>
            <item>0: UTF-8 only.</item>
            <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.</item>
            <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8.
            (Tries to detect UTF-32 first.)</item>
            <item>3: Detect UTF-16 using BOM, otherwise UTF-8.</item>
            <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to
            detect UTF-32 first.)</item></list>.</param>
            <param name='errorThrow'>If true, will throw an exception if
            invalid byte sequences (in the detected encoding) are found in the
            byte stream. If false, replaces those byte sequences with
            replacement characters (U+FFFD) as the stream is read.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean,System.Boolean)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class.</summary>
            <param name='stream'>A readable byte stream.</param>
            <param name='mode'>The method to use when detecting encodings other
            than UTF-8 in the byte stream. This usually involves checking
            whether the stream begins with a byte-order mark (BOM, U+FEFF) or
            a non-zero basic code point (NZB, U+0001 to U+007F) before
            reading the rest of the stream. This value can be one of the
            following:
            <list>
            <item>0: UTF-8 only.</item>
            <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.</item>
            <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8.
            (Tries to detect UTF-32 first.)</item>
            <item>3: Detect UTF-16 using BOM, otherwise UTF-8.</item>
            <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to
            detect UTF-32 first.)</item></list>.</param>
            <param name='errorThrow'>If true, will throw an exception if
            invalid byte sequences (in the detected encoding) are found in the
            byte stream. If false, replaces those byte sequences with
            replacement characters (U+FFFD) as the stream is read.</param>
            <param name='dontSkipUtf8Bom'>If the stream is detected as UTF-8
            and this parameter is <c>true</c>, won't skip the BOM character if
            it occurs at the start of the stream.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.String)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class
            using a Unicode 16-bit string; if the string begins with a
            byte-order mark (U+FEFF), it won't be skipped, and any unpaired
            surrogate code points (U+D800 to U+DFFF) in the string are
            replaced with replacement characters (U+FFFD).</summary>
            <param name='str'>The string to read.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.String,System.Boolean)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class
            using a Unicode 16-bit string; any unpaired surrogate code points
            (U+D800 to U+DFFF) in the string are replaced with replacement
            characters (U+FFFD).</summary>
            <param name='str'>The string to read.</param>
            <param name='skipByteOrderMark'>If true and the string begins with
            a byte-order mark (U+FEFF), will skip that code point as it reads
            the string.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.#ctor(System.String,System.Boolean,System.Boolean)">
<summary>Initializes a new instance of the <see cref='CharacterReader'/> class
            using a Unicode 16-bit string.</summary>
            <param name='str'>The string to read.</param>
            <param name='skipByteOrderMark'>If true and the string begins with
            a byte-order mark (U+FEFF), will skip that code point as it reads
            the string.</param>
            <param name='errorThrow'>If true, will throw an exception if
            unpaired surrogate code points (U+D800 to U+DFFF) are found in
            the string. If false, replaces those byte sequences with
            replacement characters (U+FFFD) as the stream is read.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a series of code points from a Unicode stream or a
            string.</summary>
            <param name='chars'>An array where the code points that were read
            will be stored.</param>
            <param name='index'>A zero-based index showing where the desired
            portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The number of elements in the desired portion
            of <paramref name='chars'/> (but not more than <paramref name='chars'/> 's length).</param>
            <returns>The number of code points read from the stream. This can
            be less than the <paramref name='length'/> parameter if the end of
            the stream is reached.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='chars'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref name='index'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref name='chars'/> 's length minus <paramref name='index'/> is less
            than <paramref name='length'/>.</exception>
</doc>
<doc name="M:PeterO.Cbor.CharacterReader.ReadChar">
<summary>Reads the next character from a Unicode stream or a
            string.</summary>
            <returns>The next character, or -1 if the end of the string or
            stream was reached.</returns>
</doc>
<doc name="M:PeterO.Cbor.FastInteger2.Multiply(System.Int32)">
<summary>Sets this object&#x27;s value to the current value times
            another integer.</summary>
            <param name='val'>The integer to multiply by.</param>
            <returns>This instance.</returns>
</doc>
<doc name="P:PeterO.Cbor.FastInteger2.Sign">
<summary>Gets the sign of this object&#x27;s value.</summary>
            <value>1 if positive, -1 if negative, 0 if zero.</value>
</doc>
<doc name="M:PeterO.Cbor.FastInteger2.Subtract(PeterO.Cbor.FastInteger2)">
<summary>Sets this object&#x27;s value to the current value minus
            the given FastInteger value.</summary>
            <param name='val'>The subtrahend.</param>
            <returns>This instance.</returns>
</doc>
<doc name="M:PeterO.Cbor.FastInteger2.SubtractInt(System.Int32)">
<summary>Sets this object&#x27;s value to the current value minus
            the given integer.</summary>
            <param name='val'>The subtrahend.</param>
            <returns>This instance.</returns>
</doc>
<doc name="T:PeterO.Cbor.ICBORConverter`1">
<summary>Interface implemented by classes that convert objects of
            arbitrary types to CBOR objects.</summary>
            <typeparam name='T'>Type to convert to a CBOR object.</typeparam>
</doc>
<doc name="M:PeterO.Cbor.ICBORConverter`1.ToCBORObject(`0)">
<summary>Converts an object to a CBOR object.</summary>
            <param name='obj'>An object to convert to a CBOR object.</param>
            <returns>A CBOR object.</returns>
</doc>
<doc name="T:PeterO.Cbor.ICBORTag">
<summary>Implemented by classes that validate CBOR objects
            belonging to a specific tag.</summary>
</doc>
<doc name="M:PeterO.Cbor.ICBORTag.GetTypeFilter">
<summary>Gets a type filter specifying what kinds of CBOR objects
            are supported by this tag.</summary>
            <returns>A CBOR type filter.</returns>
</doc>
<doc name="M:PeterO.Cbor.ICBORTag.ValidateObject(PeterO.Cbor.CBORObject)">
<summary>Generates a CBOR object based on the data of another
            object. If the data is not valid, should throw a
            CBORException.</summary>
            <param name='obj'>A CBOR object with the corresponding tag handled
            by the ICBORTag object.</param>
            <returns>A CBORObject object. Note that this method may choose to
            return the same object as the parameter.</returns>
</doc>
<doc name="T:PeterO.Cbor.ICharacterInput">
<summary>An interface for reading Unicode characters from a data
            source.</summary>
</doc>
<doc name="M:PeterO.Cbor.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>Index in the output buffer to start writing
            to.</param>
            <param name='length'>Maximum number of code points to
            write.</param>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>
</doc>
<doc name="M:PeterO.Cbor.ICharacterInput.ReadChar">
<summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>
</doc>
<doc name="T:PeterO.Cbor.StringRefs">
<summary>Implements CBOR string references, described at
            <c>http://cbor.schmorp.de/stringref</c></summary>
</doc>
<doc name="T:PeterO.Cbor.URIUtility">
<summary>Contains utility methods for processing Uniform Resource
            Identifiers (URIs) and Internationalized Resource Identifiers
            (IRIs) under RFC3986 and RFC3987, respectively. In the following
            documentation, URIs and IRIs include URI references and IRI
            references, for convenience.</summary>
</doc>
<doc name="T:PeterO.Cbor.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when
            parsing IRIs and URIs.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Even with this mode, strings with unpaired
            surrogate code points are considered invalid.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In
            particular, many code points outside the Basic Latin range (U+0000 to U+007F) are allowed. Strings with unpaired surrogate code
            points are considered invalid.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Unpaired surrogate code points are treated as
            though they were replacement characters instead for the purposes of
            these rules, so that strings with those code points are not
            considered invalid strings.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Code points outside the Basic Latin range (U+0000 to U+007F) are not allowed.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that
            code points outside the Basic Latin range (U+0000 to U+007F)
            are not allowed.</summary>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)">
<summary>Escapes characters that cannot appear in URIs or IRIs. The
            function is idempotent; that is, calling the function again on the
            result with the same mode doesn't change the result.</summary>
            <param name='s'>A string to escape.</param>
            <param name='mode'>A 32-bit signed integer.</param>
            <returns>A string possibly containing escaped characters, or null
            if s is null.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasScheme(System.String)">
<summary>
            Determines whether the string is a valid IRI with a
            scheme component. This can be used to check for
            relative IRI references.
            <para>The following cases return true:</para>
            <code> xx-x:mm example:/ww </code>
            The following cases return false:
            <code> x@y:/z /x/y/z example.xyz </code>
            </summary>
            <param name='refValue'>A string representing an IRI to
            check.</param>
            <returns><c>true</c> if the string is a valid IRI with a scheme component;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)">
<summary>
            Determines whether the string is a valid URI with a
            scheme component. This can be used to check for
            relative URI references. The following cases return
            true:
            <code> http://example/z xx-x:mm example:/ww </code>
            The following cases return false:
            <code> x@y:/z /x/y/z example.xyz </code>
            </summary>
            <param name='refValue'>A string representing an IRI to
            check.</param>
            <returns><c>true</c> if the string is a valid URI with a scheme component;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE
            reference under RDFA 1.1. (The CURIE reference is the part after
            the colon.).</summary>
            <param name='s'>A string containing a CURIE reference. Can be
            null.</param>
            <param name='offset'>A zero-based index showing where the desired
            portion of "s" begins.</param>
            <param name='length'>The number of elements in the desired portion
            of "s" (but not more than "s" 's length).</param>
            <returns><c>true</c> if the substring is a valid CURIE reference under
            RDFA 1; otherwise, <c>false</c>. Returns false if <paramref name='s'/> is
            null.</returns>
            <exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='s'/> 's length, or <paramref name='s'/> ' s length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>--.</exception>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or
            IRI.</summary>
            <param name='refValue'>A string representing a URI or IRI
            reference. Example: <c>dir/file.txt</c>.</param>
            <param name='baseURI'>A string representing an absolute URI
            reference. Example: <c>http://example.com/my/path/</c>.</param>
            <returns>The resolved IRI, or null if <paramref name='refValue'/>
            is null or is not a valid IRI. If base is null or is not a valid
            IRI, returns refValue. Example:
            <c>http://example.com/my/path/dir/file.txt</c>.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or
            IRI.</summary>
            <param name='refValue'>A string representing a URI or IRI
            reference. Example: <c>dir/file.txt</c>. Can be null.</param>
            <param name='baseURI'>A string representing an absolute URI
            reference. Example: <c>http://example.com/my/path/</c>.</param>
            <param name='parseMode'>Parse mode that specifies whether certain
            characters are allowed when parsing IRIs and URIs.</param>
            <returns>The resolved IRI, or null if <paramref name='refValue'/>
            is null or is not a valid IRI. If base is null or is not a valid
            IRI, returns refValue.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI)
            reference under RFC3987. If the IRI reference is syntactically
            valid, splits the string into its components and returns an array
            containing the indices into the components.</summary>
            <returns>If the string is a valid IRI reference, returns an array
            of 10 integers. Each of the five pairs corresponds to the start and
            end index of the IRI's scheme, authority, path, query, or fragment
            component, respectively. If a component is absent, both indices in
            that pair will be -1. If the string is null or is not a valid IRI,
            returns null.</returns>
            <param name='s'>A string that contains an IRI. Can be null.</param>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI)
            reference under RFC3987. If the IRI is syntactically valid, splits
            the string into its components and returns an array containing the
            indices into the components.</summary>
            <param name='s'>A string representing an IRI. Can be null.</param>
            <param name='parseMode'>A ParseMode object.</param>
            <returns>If the string is a valid IRI reference, returns an array
            of 10 integers. Each of the five pairs corresponds to the start and
            end index of the IRI's scheme, authority, path, query, or fragment
            component, respectively. If a component is absent, both indices in
            that pair will be -1. If the string is null or is not a valid IRI,
            returns null.</returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized
            Resource Identifier (IRI) under RFC3987. If the IRI is
            syntactically valid, splits the string into its components and
            returns an array containing the indices into the
            components.</summary>
            <param name='s'>A string that contains an IRI. Can be null.</param>
            <param name='offset'>A zero-based index showing where the desired
            portion of "s" begins.</param>
            <param name='length'>The length of the desired portion of "s" (but
            not more than "s" 's length).</param>
            <param name='parseMode'>Parse mode that specifies whether certain
            characters are allowed when parsing IRIs and URIs.</param>
            <returns>If the string is a valid IRI, returns an array of 10
            integers. Each of the five pairs corresponds to the start and end
            index of the IRI's scheme, authority, path, query, or fragment
            component, respectively. If a component is absent, both indices in
            that pair will be -1 (an index won't be less than 0 in any other
            case). If the string is null or is not a valid IRI, returns
            null.</returns>
            <exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='s'/> 's length, or <paramref name='s'/> ' s length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='s'/> is null.</exception>
</doc>
<doc name="T:PeterO.DataUtilities">
<summary>Contains methods useful for reading and writing strings.
            It is designed to have no dependencies other than the basic runtime
            class library.
            <para>Many of these methods work with text encoded in UTF-8, an
            encoding form of the Unicode Standard which uses one byte to encode
            the most basic characters and two to four bytes to encode other
            characters. For example, the <c>GetUtf8</c> method converts a text
            string to an array of bytes in UTF-8.</para>
            <para>In C# and Java, text strings are represented as sequences of
            16-bit values called <c>char</c> s. These sequences are well-formed
            under UTF-16, a 16-bit encoding form of Unicode, except if they
            contain unpaired surrogate code points. (A surrogate code point is
            used to encode supplementary characters, those with code points U+10000 or higher, in UTF-16. A surrogate pair is a high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to U+DFFF]. An unpaired surrogate code point is a surrogate not
            appearing in a surrogate pair.) Many of the methods in this class
            allow setting the behavior to follow when unpaired surrogate code
            points are found in text strings, such as throwing an error or
            treating the unpaired surrogate as a replacement character (U+FFFD).</para></summary>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">
<summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>A text string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is less than 0, or is the string's
            length or greater. Returns the replacement character (U+FFFD) if
            the current character is an unpaired surrogate code
            point.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>A text string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the previous character is an unpaired surrogate code
            point: if 0, return the replacement character (U+FFFD); if 1,
            return the value of the surrogate code point; if neither 0 nor 1,
            return -1.</param>
            <returns>The Unicode code point at the current position. Returns -1
            if <paramref name='index'/> is less than 0, or is the string's
            length or greater. Returns a value as specified under <paramref name='surrogateBehavior'/> if the previous character is an unpaired
            surrogate code point.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">
<summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>A text string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns the replacement character (U+FFFD) if the
            previous character is an unpaired surrogate code point.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>A text string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the previous character is an unpaired surrogate code
            point: if 0, return the replacement character (U+FFFD); if 1,
            return the value of the surrogate code point; if neither 0 nor 1,
            return -1.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns a value as specified under <paramref name='surrogateBehavior'/> if the previous character is an unpaired
            surrogate code point.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">
<summary>Compares two strings in Unicode code point order. Unpaired
            surrogates are treated as individual code points.</summary>
            <param name='strA'>The first string. Can be null.</param>
            <param name='strB'>The second string. Can be null.</param>
            <returns>A value indicating which string is " less" or " greater" .
            0: Both strings are equal or null. Less than 0: a is null and b
            isn't; or the first code point that's different is less in A than
            in B; or b starts with a and is longer than a. Greater than 0: b is
            null and a isn't; or the first code point that's different is
            greater in A than in B; or a starts with b and is longer than
            b.</returns>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">
<summary>Encodes a string in UTF-8 as a byte array.</summary>
            <param name='str'>A text string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string contains an
            unpaired surrogate code point and <paramref name='replace'/> is
            false, or an internal error occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">
<summary>Encodes a string in UTF-8 as a byte array.</summary>
            <param name='str'>A text string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string contains an
            unpaired surrogate code point and <paramref name='replace'/> is
            false, or an internal error occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">
<summary>Calculates the number of bytes needed to encode a string
            in UTF-8.</summary>
            <param name='str'>A text string.</param>
            <param name='replace'>If true, treats unpaired surrogate code
            points as having 3 UTF-8 bytes (the UTF-8 length of the replacement
            character U+FFFD).</param>
            <returns>The number of bytes needed to encode the given string in
            UTF-8, or -1 if the string contains an unpaired surrogate code
            point and <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">
<summary>Generates a text string from a UTF-8 byte array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The string is not
            valid UTF-8 and <paramref name='replace'/> is false.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">
<summary>Generates a text string from a portion of a UTF-8 byte
            array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8
            string.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bytes'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The portion of the
            byte array is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is less than 0, or offset plus bytesCount is
            greater than the length of "data" .</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data
            stream.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was read without errors, -1 if the
            string is not valid UTF-8 and <paramref name='replace'/> is false,
            or -2 if the end of the stream was reached before the last
            character was read completely (which is only the case if <paramref name='bytesCount'/> is 0 or greater).</returns>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null or <paramref name='builder'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a byte
            array.</summary>
            <param name='data'>A byte array containing a UTF-8 string.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8
            string.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>0 if the entire string was read without errors, or -1 if
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='data'/> is null or <paramref name='builder'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is less than 0, or offset plus bytesCount is
            greater than the length of <paramref name='data'/>.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">
<summary>Reads a string in UTF-8 encoding from a data stream in
            full and returns that string. Replaces invalid encoding with the
            replacement character (U+FFFD).</summary>
            <param name='stream'>A readable data stream.</param>
            <returns>The string read.</returns>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data stream and
            returns that string.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, throws an error if an
            unpaired surrogate code point is seen.</param>
            <returns>The string read.</returns>
            <exception cref='T:System.IO.IOException'>An I/O error occurred;
            or, the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">
<summary>Returns a string with the basic upper-case letters A to Z
            (U+0041 to U+005A) converted to lower-case. Other characters
            remain unchanged.</summary>
            <param name='str'>A text string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">
<summary>Writes a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was written; or -1 if the string
            contains an unpaired surrogate code point and <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The zero-based index where the string portion
            to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='offset'/> is less than 0, <paramref name='length'/>
            is less than 0, or <paramref name='offset'/> plus <paramref name='length'/> is greater than the string's length.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The zero-based index where the string portion
            to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='offset'/> is less than 0, <paramref name='length'/>
            is less than 0, or <paramref name='offset'/> plus <paramref name='length'/> is greater than the string's length.</exception>
            <exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="T:PeterO.ExtendedDecimal">
<summary>
            <para><b>This class is largely obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.EDecimal</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET), or <c>com.upokecenter.numbers.EDecimal</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).  This new class can be used in the <c>CBORObject.FromObject(Object)</c>
            method (by including the new library in your code, among other things), but this version of the CBOR library doesn't
            include any methods that explicitly take an <c>EDecimal</c> as a parameter
            or return value.</b></para>
            Represents an arbitrary-precision decimal floating-point
            number.
            <para><b>About decimal arithmetic</b></para>
            <para>
            Decimal (base-10) arithmetic, such as that provided by this class,
            is appropriate for calculations involving such real-world data
            as prices and other sums of money, tax rates, and measurements.  These calculations
            often involve multiplying or dividing one decimal with another
            decimal, or performing other operations on decimal numbers.
            Many of these calculations also rely on rounding behavior in which
            the result after rounding is a decimal number (for example, multiplying
            a price by a premium rate, then rounding, should result in a decimal
            amount of money).
            </para>
            <para>On the other hand, most implementations of
            <c>float</c> and <c>double</c>, including in C# and Java,
            store numbers in a binary (base-2) floating-point format and use 
            binary floating-point arithmetic.  Many decimal numbers
            can't be represented exactly in binary floating-point format (regardless
            of its length). Applying binary arithmetic to numbers intended 
            to be decimals can sometimes lead to unintuitive results, 
            as is shown in the description for the FromDouble() method 
            of this class.</para>
            <para><b>About ExtendedDecimal instances</b></para>
            <para>
            Each instance of this class consists of an integer mantissa and an integer exponent,
            both arbitrary-precision. The value of the number equals mantissa *
            10^exponent.</para>
            <para>The mantissa is the value of the digits that make up a
            number, ignoring the decimal point and exponent. For example, in
            the number 2356.78, the mantissa is 235678. The exponent is where
            the "floating" decimal point of the number is located. A positive
            exponent means "move it to the right", and a negative exponent
            means "move it to the left." In the example 2, 356.78, the exponent
            is -2, since it has 2 decimal places and the decimal point is
            "moved to the left by 2." Therefore, in the arbitrary-precision
            decimal representation, this number would be stored as 235678 *
            10^-2.</para>
            <para>The mantissa and exponent format preserves trailing zeros in
            the number's value. This may give rise to multiple ways to store
            the same value. For example, 1.00 and 1 would be stored
            differently, even though they have the same value. In the first
            case, 100 * 10^-2 (100 with decimal point moved left by 2), and in
            the second case, 1 * 10^0 (1 with decimal point moved 0).</para>
            <para>This class also supports values for negative zero,
            not-a-number (NaN) values, and infinity. <b>Negative zero</b> is
            generally used when a negative number is rounded to 0; it has the
            same mathematical value as positive zero. <b>Infinity</b> is
            generally used when a non-zero number is divided by zero, or when a
            very high number can't be represented in a given exponent range.
            <b>Not-a-number</b> is generally used to signal errors.</para>
            <para>This class implements the General Decimal Arithmetic
            Specification version 1.70 (except part of chapter 6):
            <c>http://speleotrove.com/decimal/decarith.html</c></para>
            <para><b>Errors and Exceptions</b></para>
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless noted
            otherwise.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless noted otherwise. Invalid operations
            will also return a quiet NaN, as stated in the individual
            methods.</para>
            <para>Unless noted otherwise, passing a null arbitrary-precision
            decimal argument to any method here will throw an exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the flag's trap is enabled in the precision context
            (see EContext's Traps property).</para>
            <para>If an operation requires creating an intermediate value that might be too big to
            fit in memory (or might require more than 2 gigabytes of memory to
            store -- due to the current use of a 32-bit integer internally as a length), the
            operation may signal an invalid-operation flag and return not-a-number
            (NaN).  In certain rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Serialization</b></para>
            <para>An arbitrary-precision decimal value can be serialized (converted
            to a stable format) in one of the following ways:</para>
            <list>
            <item>By calling the toString() method, which will always return
            distinct strings for distinct arbitrary-precision decimal
            values.</item>
            <item>By calling the UnsignedMantissa, Exponent, and IsNegative
            properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision decimal
            value.</item></list>
            <para><b>Thread safety</b></para>
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which only checks if each side of
            the operator is the same instance).</para>
            <para><b>Comparison considerations</b></para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method.  The CompareTo method compares
            the mathematical values of the two instances passed to it (and
            considers two different NaN values as equal), while two instances
            with the same mathematical value, but different exponents, will be
            considered unequal under the Equals method.</para>
            </summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Abs">
<summary>Gets the absolute value of this object.</summary>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Abs(PeterO.PrecisionContext)">
<summary>Finds the absolute value of this object (if it&#x27;s
            negative, it becomes positive).</summary>
            <param name='context'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The absolute value of this object.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Add(PeterO.ExtendedDecimal)">
<summary>Adds this object and another decimal number and returns
            the result.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <returns>The sum of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Add(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Finds the sum of this object and another object. The
            result's exponent is set to the lower of the exponents of the two
            operands.</summary>
            <param name='otherValue'>The number to add to.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The sum of thisValue and the other object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CompareTo(PeterO.ExtendedDecimal)">
<summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CompareToBinary(PeterO.ExtendedFloat)">
<summary>Compares an arbitrary-precision binary float with this
            instance.</summary>
            <param name='other'>The other object to compare. Can be
            null.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            Returns 0 if both values are NaN (even signaling NaN) and 1 if this
            value is NaN (even signaling NaN) and the other isn't, or if the
            other value is null.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CompareToSignal(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <param name='ctx'>A precision context. The precision, rounding, and
            exponent range are ignored. If HasFlags of the context is true,
            will store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CompareToWithContext(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <param name='ctx'>A precision context. The precision, rounding, and
            exponent range are ignored. If HasFlags of the context is true,
            will store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Create(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Creates a number with the value
            exponent*10^mantissa.</summary>
            <param name='mantissa'>The un-scaled value.</param>
            <param name='exponent'>The decimal exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Create(System.Int32,System.Int32)">
<summary>Creates a number with the value
            exponent*10^mantissa.</summary>
            <param name='mantissaSmall'>The un-scaled value.</param>
            <param name='exponentSmall'>The decimal exponent.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CreateNaN(PeterO.BigInteger)">
<summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <returns>A quiet not-a-number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null or is less than 0.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.CreateNaN(PeterO.BigInteger,System.Boolean,System.Boolean,PeterO.PrecisionContext)">
<summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <param name='ctx'>A context object for arbitrary-precision
            arithmetic settings.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null or is less than 0.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Divide(PeterO.ExtendedDecimal)">
<summary>Divides this object by another decimal number and returns
            the result. When possible, the result will be exact.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the result can't be exact because it would
            have a nonterminating decimal expansion.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Divide(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Divides this arbitrary-precision decimal number by another
            arbitrary-precision decimal number. The preferred exponent for the
            result is this object's exponent minus the divisor's
            exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0; or, either <paramref name='ctx'/>
            is null or <paramref name='ctx'/> 's precision is 0, and the result
            would have a nonterminating decimal expansion; or, the rounding
            mode is Rounding.Unnecessary and the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideAndRemainderNaturalScale(PeterO.ExtendedDecimal)">
<summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideAndRemainderNaturalScale(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's HasFlags is true and the
            integer part of the division result doesn't fit the precision and
            exponent range without rounding.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToExponent(PeterO.ExtendedDecimal,PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision decimal
            number.</param>
            <param name='exponent'>The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point. A
            positive number places the cutoff point to the left of the usual
            decimal point.</param>
            <param name='ctx'>A precision context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is
            Rounding.Unnecessary and the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> or <paramref name='exponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToExponent(PeterO.ExtendedDecimal,PeterO.BigInteger,PeterO.Rounding)">
<summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision decimal
            number.</param>
            <param name='desiredExponent'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the rounding mode is Rounding.Unnecessary and
            the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> or <paramref name='desiredExponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToExponent(PeterO.ExtendedDecimal,System.Int64,PeterO.PrecisionContext)">
<summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision decimal
            number.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='ctx'>A precision context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is
            Rounding.Unnecessary and the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToExponent(PeterO.ExtendedDecimal,System.Int64,PeterO.Rounding)">
<summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision decimal
            number.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is Rounding.Unnecessary and
            the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToIntegerNaturalScale(PeterO.ExtendedDecimal)">
<summary>Divides two arbitrary-precision decimal numbers, and
            returns the integer part of the result, rounded down, with the
            preferred exponent set to this value's exponent minus the divisor's
            exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToIntegerNaturalScale(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Divides this object by another object, and returns the
            integer part of the result, with the preferred exponent set to this
            value's exponent minus the divisor's exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the integer part of the
            result. Flags will be set on the given context only if the
            context's HasFlags is true and the integer part of the result
            doesn't fit the precision and exponent range without
            rounding.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagInvalid and returns not-a-number (NaN) if the return
            value would overflow the exponent range. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is Rounding.Unnecessary and
            the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToIntegerZeroScale(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If HasFlags of the context is true, will also store
            the flags resulting from the operation (the flags are in addition
            to the pre-existing flags). Can be null.</param>
            <returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.DivideToSameExponent(PeterO.ExtendedDecimal,PeterO.Rounding)">
<summary>Divides this object by another decimal number and returns
            a result with the same exponent as this object (the
            dividend).</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is Rounding.Unnecessary and
            the result is not exact.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Equals(PeterO.ExtendedDecimal)">
<summary>Determines whether this object&#x27;s mantissa and
            exponent are equal to those of another object.</summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns><c>true</c> if this object's mantissa and exponent are equal to
            those of another object; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Equals(System.Object)">
<summary>Determines whether this object&#x27;s mantissa and
            exponent are equal to those of another object and that other object
            is an arbitrary-precision decimal number.</summary>
            <param name='obj'>An arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Exp(PeterO.PrecisionContext)">
<summary>Finds e (the base of natural logarithms) raised to the
            power of this object&#x27;s value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the exponential function's
            results are generally not exact.</i></param>
            <returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given precision.
            Signals FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.Exponent">
<summary>Gets this object&#x27;s exponent. This object&#x27;s value
            will be an integer if the exponent is positive or zero.</summary>
            <value>This object&apos;s exponent. This object&apos;s value will
            be an integer if the exponent is positive or zero.</value>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromBigInteger(PeterO.BigInteger)">
<summary>Converts a big integer to an arbitrary precision
            decimal.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigint'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromDouble(System.Double)">
<summary>Creates a decimal number from a 64-bit binary floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first. Remember, though, that
            the exact value of a 64-bit binary floating-point number is not always the
            value that results when passing a literal decimal number (for example,
            calling <c>ExtendedDecimal.FromDouble(0.1f)</c> ), since not all
            decimal numbers can be converted to exact binary numbers (in the
            example given, the resulting arbitrary-precision decimal will be
            the value of the closest "double" to 0.1, not 0.1 exactly). To
            create an arbitrary-precision decimal number from a decimal number,
            use FromString instead in most cases (for example:
            <c>ExtendedDecimal.FromString("0.1")</c> ).</summary>
            <param name='dbl'>A 64-bit floating-point number.</param>
            <returns>A decimal number with the same value as <paramref name='dbl'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromExtendedFloat(PeterO.ExtendedFloat)">
<summary>Creates a decimal number from an arbitrary-precision
            binary floating-point number.</summary>
            <param name='bigfloat'>An arbitrary-precision binary floating-point number.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigfloat'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromInt32(System.Int32)">
<summary>Creates a decimal number from a 32-bit signed
            integer.</summary>
            <param name='valueSmaller'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent set to 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromInt64(System.Int64)">
<summary>Creates a decimal number from a 64-bit signed
            integer.</summary>
            <param name='valueSmall'>A 64-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromSingle(System.Single)">
<summary>Creates a decimal number from a 32-bit binary floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first. Remember, though, that
            the exact value of a 32-bit binary floating-point number is not always the
            value that results when passing a literal decimal number (for example,
            calling <c>ExtendedDecimal.FromSingle(0.1f)</c> ), since not all
            decimal numbers can be converted to exact binary numbers (in the
            example given, the resulting arbitrary-precision decimal will be
            the the value of the closest "float" to 0.1, not 0.1 exactly). To
            create an arbitrary-precision decimal number from a decimal number,
            use FromString instead in most cases (for example:
            <c>ExtendedDecimal.FromString("0.1")</c> ).</summary>
            <param name='flt'>A 32-bit floating-point number.</param>
            <returns>A decimal number with the same value as <paramref name='flt'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromString(System.String)">
<summary>Creates a decimal number from a text string that represents a
            number. See <c>FromString(String, int, int, EContext)</c> for more
            information.</summary>
            <param name='str'>A string that represents a number.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is not a correctly formatted number
            string.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromString(System.String,PeterO.PrecisionContext)">
<summary>Creates a decimal number from a text string that represents a
            number. See <c>FromString(String, int, int, EContext)</c> for more
            information.</summary>
            <param name='str'>A string that represents a number.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is not a correctly formatted number
            string.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromString(System.String,System.Int32,System.Int32)">
<summary>Creates a decimal number from a text string that represents a
            number. See <c>FromString(String, int, int, EContext)</c> for more
            information.</summary>
            <param name='str'>A string that represents a number.</param>
            <param name='offset'>A zero-based index showing where the desired
            portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is not a correctly formatted number
            string.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.PrecisionContext)">
<summary>
            <para>Creates a decimal number from a text string that represents a
            number.</para>
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            after the first digit and before the last digit.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the
            exponent.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity", "INF"
            , quiet NaN ("NaN" /"-NaN") followed by any number of digits, or
            signaling NaN ("sNaN" /"-sNaN") followed by any number of digits,
            all in any combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string portion is
            not allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='str'>A text string, a portion of which represents a
            number.</param>
            <param name='offset'>A zero-based index that identifies the start
            of the number.</param>
            <param name='length'>The length of the number within the
            string.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is not a correctly formatted number
            string.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.GetHashCode">
<summary>Calculates this object&#x27;s hash code.</summary>
            <returns>This object's hash code.</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.IsFinite">
<summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or NaN);
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsInfinity">
<summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary>
            <returns><c>true</c> if this object is positive or negative infinity;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsNaN">
<summary>Gets a value indicating whether this object is not a
            number (NaN).</summary>
            <returns><c>true</c> if this object is not a number (NaN); otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.IsNegative">
<summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary>
            <value><c>true</c> if this object is negative, including negative zero;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsNegativeInfinity">
<summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsPositiveInfinity">
<summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsQuietNaN">
<summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.IsSignalingNaN">
<summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a signaling not-a-number value;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.IsZero">
<summary>Gets a value indicating whether this object&#x27;s value
            equals 0.</summary>
            <value><c>true</c> if this object&apos;s value equals 0; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Log(PeterO.PrecisionContext)">
<summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object&#x27;s value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the ln function's results are
            generally not exact.</i></param>
            <returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0). Signals no flags
            and returns negative infinity if this object's value is
            0.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Log10(PeterO.PrecisionContext)">
<summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object&#x27;s value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the ln function's results are
            generally not exact.</i></param>
            <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.Mantissa">
<summary>Gets this object&#x27;s un-scaled value.</summary>
            <value>This object&apos;s un-scaled value. Will be negative if this
            object&apos;s value is negative (including a negative NaN).</value>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Max(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal)">
<summary>Gets the greater value between two decimal
            numbers.</summary>
            <param name='first'>An arbitrary-precision decimal number.</param>
            <param name='second'>Another arbitrary-precision decimal
            number.</param>
            <returns>The larger value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Max(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Gets the greater value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The larger value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MaxMagnitude(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal)">
<summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MaxMagnitude(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Min(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal)">
<summary>Gets the lesser value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>The smaller value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Min(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Gets the lesser value between two decimal
            numbers.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The smaller value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MinMagnitude(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal)">
<summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MinMagnitude(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>The first value to compare.</param>
            <param name='second'>The second value to compare.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointLeft(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointLeft(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointLeft(System.Int32)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointLeft(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointRight(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointRight(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>A number whose scale is increased by <paramref name='bigPlaces'/>, but not to more than 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointRight(System.Int32)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MovePointRight(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Multiply(PeterO.ExtendedDecimal)">
<summary>Multiplies two decimal numbers. The resulting exponent
            will be the sum of the exponents of the two decimal
            numbers.</summary>
            <param name='otherValue'>Another decimal number.</param>
            <returns>The product of the two decimal numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Multiply(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Multiplies two decimal numbers. The resulting scale will
            be the sum of the scales of the two decimal numbers. The result's
            sign is positive if both operands have the same sign, and negative
            if they have different signs.</summary>
            <param name='op'>Another decimal number.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The product of the two decimal numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MultiplyAndAdd(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal)">
<summary>Multiplies by one decimal number, and then adds another
            decimal number.</summary>
            <param name='multiplicand'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <returns>The result this * <paramref name='multiplicand'/> +
            <paramref name='augend'/>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='multiplicand'/> or <paramref name='augend'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MultiplyAndAdd(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Multiplies by one value, and then adds another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The result thisValue * multiplicand + augend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> or <paramref name='augend'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.MultiplyAndSubtract(PeterO.ExtendedDecimal,PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Multiplies by one value, and then subtracts another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='subtrahend'>The value to subtract.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The result thisValue * multiplicand -
            subtrahend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> or <paramref name='subtrahend'/> is
            null.</exception>
</doc>
<doc name="F:PeterO.ExtendedDecimal.NaN">
<summary>A not-a-number value.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Negate">
<summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary>
            <returns>An arbitrary-precision decimal number.  If this value is positive zero, returns positive zero.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Negate(PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but with the sign reversed.</summary>
            <param name='context'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.  If this value is positive zero, returns positive zero.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='context'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedDecimal.NegativeInfinity">
<summary>Negative infinity, less than any other number.</summary>
</doc>
<doc name="F:PeterO.ExtendedDecimal.NegativeZero">
<summary>Represents the number negative zero.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.NextMinus(PeterO.PrecisionContext)">
<summary>Finds the largest value that&#x27;s smaller than the given
            value.</summary>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.NextPlus(PeterO.PrecisionContext)">
<summary>Finds the smallest value that&#x27;s greater than the
            given value.</summary>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the smallest value that's greater than the given
            value.Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null, the precision is 0, or
            <paramref name='ctx'/> has an unlimited exponent range.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.NextToward(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Finds the next value that is closer to the other object's
            value than this object's value. Returns a copy of this value with
            the same sign as the other value if both values are
            equal.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the next value that is closer to the other object'
            s value than this object's value. Signals FlagInvalid and returns
            NaN if the parameter <paramref name='ctx'/> is null, the precision
            is 0, or <paramref name='ctx'/> has an unlimited exponent
            range.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedDecimal.One">
<summary>Represents the number 1.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.PI(PeterO.PrecisionContext)">
<summary>Finds the constant &#x3c0;, the circumference of a circle divided by its diameter.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as &#x3c0; can never be represented
            exactly.</i></param>
            <returns>The constant &#x3c0; rounded to the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the parameter <paramref name='ctx'/>
            is null or the precision is unlimited (the context's Precision
            property is 0).</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Plus(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given precision,
            using the given rounding mode and range of exponent, and also
            converts negative zero to positive zero.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="F:PeterO.ExtendedDecimal.PositiveInfinity">
<summary>Positive infinity, greater than any other
            number.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Pow(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponent'>An arbitrary-precision decimal
            number.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing
            flags).</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name='ctx'/> is null or the precision is
            unlimited (the context's Precision property is 0), and the exponent
            has a fractional part.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Pow(System.Int32)">
<summary>Raises this object&#x27;s value to the given
            exponent.</summary>
            <param name='exponentSmall'>A 32-bit signed integer.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Pow(System.Int32,PeterO.PrecisionContext)">
<summary>Raises this object&#x27;s value to the given
            exponent.</summary>
            <param name='exponentSmall'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing
            flags).</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Precision">
<summary>Finds the number of digits in this number's mantissa.
            Returns 1 if this value is 0, and 0 if this value is infinity or
            NaN.</summary>
            <returns>An arbitrary-precision integer.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Quantize(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para></summary>
            <param name='desiredExponent'>An arbitrary-precision
            integer.</param>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounded result can't fit the given
            precision, or if the context defines an exponent range and the
            given exponent is outside that range.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='desiredExponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Quantize(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but with the same exponent as another decimal number.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para></summary>
            <param name='otherValue'>A decimal number containing the desired
            exponent of the result. The mantissa is ignored. The exponent is
            the number of fractional digits in the result, expressed as a
            negative number. Can also be positive, which eliminates lower-order
            places from the number. For example, -3 means round to the
            thousandth (10^-3, 0.0001), and 3 means round to the thousand
            (10^3, 1000). A value of 0 rounds the number to an integer.</param>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if the result can't fit the given precision
            without rounding, or if the precision context defines an exponent
            range and the given exponent is outside that range.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Quantize(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para></summary>
            <param name='desiredExponentSmall'>The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounded result can't fit the given
            precision, or if the context defines an exponent range and the
            given exponent is outside that range.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Quantize(System.Int32,PeterO.Rounding)">
<summary>Returns a decimal number with the same value as this one
            but a new exponent.</summary><param name='desiredExponentSmall'>The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name='rounding'>The mode to use when the
            result needs to be rounded in order to have the given exponent.</param><returns>A decimal number with the same value as this object but
            with the exponent changed. Returns not-a-number (NaN) if the
            rounding mode is Rounding.Unnecessary and the result is not
            exact.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Reduce(PeterO.PrecisionContext)">
<summary>Removes trailing zeros from this object&#x27;s mantissa.
            For example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the
            mantissa.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Remainder(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Finds the remainder that results when dividing two
            arbitrary-precision decimal numbers.</summary>
            <param name='divisor'>An arbitrary-precision decimal
            number.</param>
            <param name='ctx'>The parameter <paramref name='ctx'/> is not
            documented yet.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RemainderNaturalScale(PeterO.ExtendedDecimal)">
<summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RemainderNaturalScale(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the return value to
            have a higher precision than given in this context. Flags will be
            set on the given context only if the context's HasFlags is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RemainderNear(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value by
            another object's value.
            <list type=''>
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor' s absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null.</param>
            <returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToBinaryPrecision(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given maximum bit
            length, using the given rounding mode and range of
            exponent.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. The precision is interpreted as the
            maximum bit length of the mantissa. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToExponent(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A decimal number rounded to the closest value
            representable in the given precision, meaning if the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the precision
            context defines an exponent range, the new exponent must be changed
            to the given exponent when rounding, and the given exponent is
            outside of the valid range of the precision context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToExponent(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A decimal number rounded to the closest value
            representable in the given precision, meaning if the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the precision
            context defines an exponent range, the new exponent must be changed
            to the given exponent when rounding, and the given exponent is
            outside of the valid range of the precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToExponentExact(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag
            if the result would be inexact.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A context object for arbitrary-precision
            arithmetic settings.</param>
            <returns>A decimal number rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the precision context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the precision context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToExponentExact(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag
            if the result would be inexact.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A context object for arbitrary-precision
            arithmetic settings.</param>
            <returns>A decimal number rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the precision context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToIntegralExact(PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag
            if the result would be inexact.</summary>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A decimal number rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the precision context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToIntegralNoRoundedFlag(PeterO.PrecisionContext)">
<summary>Returns a decimal number with the same value as this
            object but rounded to an integer, without adding the FlagInexact or
            FlagRounded flags.</summary>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags), except that this function will
            never add the FlagRounded and FlagInexact flags (the only
            difference between this and RoundToExponentExact). Can be null, in
            which case the default rounding mode is HalfEven.</param>
            <returns>A decimal number rounded to the closest integer
            representable in the given precision, meaning if the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the precision
            context defines an exponent range, the new exponent must be changed
            to 0 when rounding, and 0 is outside of the valid range of the
            precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.RoundToPrecision(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given precision,
            using the given rounding mode and range of exponent.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ScaleByPowerOfTen(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ScaleByPowerOfTen(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with its scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>A number whose scale is increased by <paramref name='bigPlaces'/>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ScaleByPowerOfTen(System.Int32)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ScaleByPowerOfTen(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.Sign">
<summary>Gets this value&#x27;s sign: -1 if negative; 1 if
            positive; 0 if zero.</summary>
            <value>This value&apos;s sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
</doc>
<doc name="F:PeterO.ExtendedDecimal.SignalingNaN">
<summary>A not-a-number value that signals an invalid operation
            flag when it&#x27;s passed as an argument to any arithmetic
            operation in arbitrary-precision decimal.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.SquareRoot(PeterO.PrecisionContext)">
<summary>Finds the square root of this object&#x27;s
            value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the square root function's
            results are generally not exact for many inputs.</i></param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Subtract(PeterO.ExtendedDecimal)">
<summary>Subtracts an arbitrary-precision decimal number from this
            instance and returns the result.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Subtract(PeterO.ExtendedDecimal,PeterO.PrecisionContext)">
<summary>Subtracts an arbitrary-precision decimal number from this
            instance.</summary>
            <param name='otherValue'>An arbitrary-precision decimal
            number.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedDecimal.Ten">
<summary>Represents the number 10.</summary>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToBigInteger">
<summary>Converts this value to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            a big integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToBigIntegerExact">
<summary>Converts this value to an arbitrary-precision integer,
            checking whether the fractional part of the integer would be
            lost.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value
            is not an exact integer.</exception>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToDouble">
<summary>Converts this value to a 64-bit floating-point number. The
            half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's mantissa for a quiet NaN, and clears it for
            a signaling NaN. Then the next highest bit of the mantissa is
            cleared for a quiet NaN, and set for a signaling NaN. Then the
            other bits of the mantissa are set to the lowest bits of this
            object's unsigned mantissa.</para></summary>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToEngineeringString">
<summary>Same as toString(), except that when an exponent is used
            it will be a multiple of 3.</summary>
            <returns>A text string.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToExtendedFloat">
<summary>Creates a binary floating-point number from this
            object&#x27;s value. Note that if the binary floating-point number
            contains a negative exponent, the resulting value might not be
            exact, in which case the resulting binary float will be an
            approximation of this decimal number's value. (NOTE: This
            documentation previously said the binary float will contain enough
            precision to accurately convert it to a 32-bit or 64-bit floating
            point number.  Due to double rounding, this will generally not
            be the case for certain numbers converted from decimal
            to ExtendedFloat via this method and in turn converted
            to <c>double</c> or <c>float</c>.).</summary>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToPlainString">
<summary>Converts this value to a string, but without using
            exponential notation.</summary>
            <returns>A text string.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToSingle">
<summary>Converts this value to a 32-bit floating-point number. The
            half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's mantissa for a quiet NaN, and clears it for
            a signaling NaN. Then the next highest bit of the mantissa is
            cleared for a quiet NaN, and set for a signaling NaN. Then the
            other bits of the mantissa are set to the lowest bits of this
            object's unsigned mantissa.</para></summary>
            <returns>The closest 32-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.ToString">
<summary>Converts this value to a string. Returns a value
            compatible with this class's FromString method.</summary>
            <returns>A string representation of this object.</returns>
</doc>
<doc name="M:PeterO.ExtendedDecimal.Ulp">
<summary>Returns the unit in the last place. The mantissa will be 1
            and the exponent will be this number's exponent. Returns 1 with an
            exponent of 0 if this number is infinity or NaN.</summary>
            <returns>An arbitrary-precision decimal number.</returns>
</doc>
<doc name="P:PeterO.ExtendedDecimal.UnsignedMantissa">
<summary>Gets the absolute value of this object&#x27;s un-scaled
            value.</summary>
            <value>The absolute value of this object&apos;s un-scaled
            value.</value>
</doc>
<doc name="F:PeterO.ExtendedDecimal.Zero">
<summary>Represents the number 0.</summary>
</doc>
<doc name="T:PeterO.ExtendedFloat">
<summary>
            <para><b>This class is largely obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.EFloat</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET), or <c>com.upokecenter.numbers.EFloat</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).  This new class can be used in the <c>CBORObject.FromObject(Object)</c>
            method (by including the new library in your code, among other things), but this version of the CBOR library doesn't
            include any methods that explicitly take an <c>EFloat</c> as a parameter
            or return value.</b></para>
            <para>
            Represents an arbitrary-precision binary floating-point
            number. Consists of an integer mantissa and an integer exponent,
            both arbitrary-precision. The value of the number equals mantissa *
            2^exponent. This class also supports values for negative zero,
            not-a-number (NaN) values, and infinity.</para>
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless noted
            otherwise.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless noted otherwise.</para>
            <para>Unless noted otherwise, passing a null arbitrary-precision
            binary float argument to any method here will throw an
            exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the operation's trap is enabled in the precision
            context (see PrecisionContext's Traps property).</para>
            <para>An arbitrary-precision binary float value can be serialized
            in one of the following ways:</para>
            <list>
            <item>By calling the toString() method. However, not all strings
            can be converted back to an arbitrary-precision binary float
            without loss, especially if the string has a fractional
            part.</item>
            <item>By calling the UnsignedMantissa, Exponent, and IsNegative
            properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision binary float
            value.</item></list>
            <para>If an operation requires creating an intermediate value that might be too big to
            fit in memory (or might require more than 2 gigabytes of memory to
            store -- due to the current use of a 32-bit integer internally as a length), the
            operation may signal an invalid-operation flag and return not-a-number
            (NaN).  In certain rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Thread safety:</b>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which only checks if each side of
            the operator is the same instance).</para></summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.Abs">
<summary>Gets the absolute value of this object.</summary>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Abs(PeterO.PrecisionContext)">
<summary>Finds the absolute value of this object (if it&#x27;s
            negative, it becomes positive).</summary>
            <param name='context'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The absolute value of this object.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Add(PeterO.ExtendedFloat)">
<summary>Adds this object and another binary float and returns the
            result.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            float.</param>
            <returns>The sum of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Add(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Finds the sum of this object and another object. The
            result's exponent is set to the lower of the exponents of the two
            operands.</summary>
            <param name='otherValue'>The number to add to.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The sum of thisValue and the other object.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.CompareTo(PeterO.ExtendedFloat)">
<summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary>
            <param name='other'>An arbitrary-precision binary float.</param>
            <returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name='other'/> is null, or 0 if both
            values are equal.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.CompareToSignal(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary>
            <param name='other'>An arbitrary-precision binary float.</param>
            <param name='ctx'>A precision context. The precision, rounding, and
            exponent range are ignored. If HasFlags of the context is true,
            will store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.CompareToWithContext(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary>
            <param name='other'>An arbitrary-precision binary float.</param>
            <param name='ctx'>A precision context. The precision, rounding, and
            exponent range are ignored. If HasFlags of the context is true,
            will store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null.</param>
            <returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Create(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Creates a number with the value
            exponent*2^mantissa.</summary>
            <param name='mantissa'>The un-scaled value.</param>
            <param name='exponent'>The binary exponent.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Create(System.Int32,System.Int32)">
<summary>Creates a number with the value
            exponent*2^mantissa.</summary>
            <param name='mantissaSmall'>The un-scaled value.</param>
            <param name='exponentSmall'>The binary exponent.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.CreateNaN(PeterO.BigInteger)">
<summary>Creates a not-a-number arbitrary-precision binary
            float.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <returns>A quiet not-a-number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='diag'/> is less than 0.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.CreateNaN(PeterO.BigInteger,System.Boolean,System.Boolean,PeterO.PrecisionContext)">
<summary>Creates a not-a-number arbitrary-precision binary
            float.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='diag'/> is less than 0.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Divide(PeterO.ExtendedFloat)">
<summary>Divides this object by another binary float and returns
            the result. When possible, the result will be exact.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>The result can't be
            exact because it would have a nonterminating binary
            expansion.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Divide(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Divides this arbitrary-precision binary float by another
            arbitrary-precision binary float object. The preferred exponent for
            the result is this object's exponent minus the divisor's
            exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>Either <paramref name='ctx'/> is null or <paramref name='ctx'/> 's precision is 0,
            and the result would have a nonterminating binary expansion; or,
            the rounding mode is Rounding.Unnecessary and the result is not
            exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideAndRemainderNaturalScale(PeterO.ExtendedFloat)">
<summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideAndRemainderNaturalScale(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale. </summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's HasFlags is true and the
            integer part of the division result doesn't fit the precision and
            exponent range without rounding.</param>
            <returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToExponent(PeterO.ExtendedFloat,PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Divides two arbitrary-precision binary floats, and gives a
            particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision binary float.</param>
            <param name='exponent'>The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point. A
            positive number places the cutoff point to the left of the usual
            decimal point.</param>
            <param name='ctx'>A precision context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the result is not exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> or <paramref name='exponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToExponent(PeterO.ExtendedFloat,PeterO.BigInteger,PeterO.Rounding)">
<summary>Divides two arbitrary-precision binary floats, and gives a
            particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision binary float.</param>
            <param name='desiredExponent'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the result is not exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> or <paramref name='desiredExponent'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToExponent(PeterO.ExtendedFloat,System.Int64,PeterO.PrecisionContext)">
<summary>Divides two arbitrary-precision binary floats, and gives a
            particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision binary float.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='ctx'>A precision context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the result is not exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToExponent(PeterO.ExtendedFloat,System.Int64,PeterO.Rounding)">
<summary>Divides two arbitrary-precision binary floats, and gives a
            particular exponent to the result.</summary>
            <param name='divisor'>An arbitrary-precision binary float.</param>
            <param name='desiredExponentSmall'>The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point. A positive number places the cutoff point to the left of the
            usual decimal point.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the result is not exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToIntegerNaturalScale(PeterO.ExtendedFloat)">
<summary>Divides two arbitrary-precision binary floats, and returns
            the integer part of the result, rounded down, with the preferred
            exponent set to this value's exponent minus the divisor's
            exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToIntegerNaturalScale(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Divides this object by another object, and returns the
            integer part of the result, with the preferred exponent set to this
            value's exponent minus the divisor's exponent.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the integer part of the
            result. Flags will be set on the given context only if the
            context's HasFlags is true and the integer part of the result
            doesn't fit the precision and exponent range without
            rounding.</param>
            <returns>The integer part of the quotient of the two objects.
            Returns null if the return value would overflow the exponent range.
            A caller can handle a null return value by treating it as positive
            infinity if both operands have the same sign or as negative
            infinity if both operands have different signs. Signals
            FlagDivideByZero and returns infinity if the divisor is 0 and the
            dividend is nonzero. Signals FlagInvalid and returns not-a-number
            (NaN) if the divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the integer part of the result is not
            exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToIntegerZeroScale(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If HasFlags of the context is true, will also store
            the flags resulting from the operation (the flags are in addition
            to the pre-existing flags). Can be null.</param>
            <returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.DivideToSameExponent(PeterO.ExtendedFloat,PeterO.Rounding)">
<summary>Divides this object by another binary float and returns a
            result with the same exponent as this object (the
            dividend).</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='rounding'>The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param>
            <returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
            <exception cref='T:System.ArithmeticException'>The rounding mode is
            Rounding.Unnecessary and the result is not exact.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Equals(PeterO.ExtendedFloat)">
<summary>Determines whether this object's mantissa and exponent are
            equal to those of another object.</summary>
            <param name='other'>An arbitrary-precision binary float.</param>
            <returns><c>true</c> if this object's mantissa and exponent are equal to
            those of another object; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Equals(System.Object)">
<summary>Determines whether this object&#x27;s mantissa and
            exponent are equal to those of another object and that other object
            is an arbitrary-precision decimal number.</summary>
            <param name='obj'>An arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.EqualsInternal(PeterO.ExtendedFloat)">
<summary>Determines whether this object's mantissa and exponent are
            equal to those of another object.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            float.</param>
            <returns><c>true</c> if this object's mantissa and exponent are equal to
            those of another object; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Exp(PeterO.PrecisionContext)">
<summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the exponential function's
            results are generally not exact.</i></param>
            <returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given
            precision.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</exception>
</doc>
<doc name="P:PeterO.ExtendedFloat.Exponent">
<summary>Gets this object&#x27;s exponent. This object&#x27;s value
            will be an integer if the exponent is positive or zero.</summary>
            <value>This object&apos;s exponent. This object&apos;s value will
            be an integer if the exponent is positive or zero.</value>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromBigInteger(PeterO.BigInteger)">
<summary>Converts a big integer to the same value as a binary
            float.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigint'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromDouble(System.Double)">
<summary>Creates a binary float from a 64-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary>
            <param name='dbl'>A 64-bit floating-point number.</param>
            <returns>A binary float with the same value as <paramref name='dbl'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromInt32(System.Int32)">
<summary>Creates a binary float from a 32-bit signed
            integer.</summary>
            <param name='valueSmaller'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision binary float with the exponent set to 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromInt64(System.Int64)">
<summary>Converts a 64-bit integer to the same value as a binary
            float.</summary>
            <param name='valueSmall'>A 64-bit signed integer.</param>
            <returns>An arbitrary-precision binary float with the exponent set to 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromSingle(System.Single)">
<summary>Creates a binary float from a 32-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary>
            <param name='flt'>A 32-bit floating-point number.</param>
            <returns>A binary float with the same value as <paramref name='flt'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String)">
<summary>Creates a binary float from a text string that represents a
            number. See the four-parameter FromString method.</summary>
            <param name='str'>The parameter <paramref name='str'/> is not
            documented yet.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            float.</returns>
            <example>
            The following example converts a number in the form of
            a string to a
            <c>double</c>
            , or a 64-bit floating point number.
            <code>
            public static double StringToDouble(String str) {
            return ExtendedFloat.FromString(str).ToDouble();
            }
            </code>
            </example>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String,PeterO.PrecisionContext)">
<summary>Creates a binary float from a text string that represents a
            number. Note that if the string contains a negative exponent, the
            resulting value might not be exact, in which case the resulting binary float will be an
            approximation of this decimal number's value.</summary>
            <param name='str'>A text string.</param>
            <param name='ctx'>A PrecisionContext object specifying the
            precision, rounding, and exponent range to apply to the parsed
            number. Can be null.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String,System.Int32,System.Int32)">
<summary>Creates a binary float from a text string that represents a
            number. Note that if the string contains a negative exponent, the
            resulting value might not be exact, in which case the resulting binary float will be an
            approximation of this decimal number's value.</summary>
            <param name='str'>A text string.</param>
            <param name='offset'>A zero-based index showing where the desired
            portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> ' s length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String,System.Int32,System.Int32,PeterO.PrecisionContext)">
<summary>Creates a binary float from a text string that represents a
            number. Note that if the string contains a negative exponent, the
            resulting value might not be exact, in which case the resulting binary float will be an
            approximation of this decimal number's value. (NOTE: This
            documentation previously said the binary float will contain enough
            precision to accurately convert it to a 32-bit or 64-bit floating
            point number.  Due to double rounding, this will generally not
            be the case for certain numbers converted from decimal
            to ExtendedFloat via this method and in turn converted
            to <c>double</c> or <c>float</c>.)
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            after the first digit and before the last digit.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the
            exponent.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits, or
            signaling NaN ("sNaN") followed by any number of digits, all in any
            combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is
            not allowed to contain white space characters, including
            spaces.</para></summary>
            <param name='str'>A text string.</param>
            <param name='offset'>A zero-based index showing where the desired
            portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <param name='ctx'>A PrecisionContext object specifying the
            precision, rounding, and exponent range to apply to the parsed
            number. Can be null.</param>
            <returns>The parsed number, converted to arbitrary-precision binary
            float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> ' s length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.GetHashCode">
<summary>Calculates this object&#x27;s hash code.</summary>
            <returns>This object's hash code.</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.IsFinite">
<summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or NaN);
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsInfinity">
<summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary>
            <returns><c>true</c> if this object is positive or negative infinity;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsNaN">
<summary>Returns whether this object is a not-a-number
            value.</summary>
            <returns><c>true</c> if this object is a not-a-number value; otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.IsNegative">
<summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary>
            <value><c>true</c> if this object is negative, including negative zero;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsNegativeInfinity">
<summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsPositiveInfinity">
<summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsQuietNaN">
<summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.IsSignalingNaN">
<summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary>
            <returns><c>true</c> if this object is a signaling not-a-number value;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.IsZero">
<summary>Gets a value indicating whether this object&#x27;s value
            equals 0.</summary>
            <value><c>true</c> if this object&apos;s value equals 0; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedFloat.Log(PeterO.PrecisionContext)">
<summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object's value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the ln function's results are
            generally not exact.</i></param>
            <returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.).</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Log10(PeterO.PrecisionContext)">
<summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object&#x27;s value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the ln function's results are
            generally not exact.</i></param>
            <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.Mantissa">
<summary>Gets this object&#x27;s un-scaled value.</summary>
            <value>This object&apos;s un-scaled value. Will be negative if this
            object&apos;s value is negative (including a negative NaN).</value>
</doc>
<doc name="M:PeterO.ExtendedFloat.Max(PeterO.ExtendedFloat,PeterO.ExtendedFloat)">
<summary>Gets the greater value between two binary
            floats.</summary>
            <param name='first'>An arbitrary-precision binary float.</param>
            <param name='second'>Another arbitrary-precision binary
            float.</param>
            <returns>The larger value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Max(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Gets the greater value between two binary
            floats.</summary>
            <param name='first'>An arbitrary-precision binary float.</param>
            <param name='second'>Another arbitrary-precision binary
            float.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The larger value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MaxMagnitude(PeterO.ExtendedFloat,PeterO.ExtendedFloat)">
<summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>Another arbitrary-precision binary
            float.</param>
            <param name='second'>An arbitrary-precision binary float.
            (3).</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MaxMagnitude(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary>
            <param name='first'>Another arbitrary-precision binary
            float.</param>
            <param name='second'>An arbitrary-precision binary float.
            (3).</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Min(PeterO.ExtendedFloat,PeterO.ExtendedFloat)">
<summary>Gets the lesser value between two binary floats.</summary>
            <param name='first'>An arbitrary-precision binary float.</param>
            <param name='second'>Another arbitrary-precision binary
            float.</param>
            <returns>The smaller value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Min(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Gets the lesser value between two binary floats.</summary>
            <param name='first'>An arbitrary-precision binary float.</param>
            <param name='second'>Another arbitrary-precision binary
            float.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The smaller value of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MinMagnitude(PeterO.ExtendedFloat,PeterO.ExtendedFloat)">
<summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>Another arbitrary-precision binary
            float.</param>
            <param name='second'>An arbitrary-precision binary float.
            (3).</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MinMagnitude(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary>
            <param name='first'>Another arbitrary-precision binary
            float.</param>
            <param name='second'>An arbitrary-precision binary float.
            (3).</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='first'/> or <paramref name='second'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointLeft(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointLeft(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointLeft(System.Int32)">
<summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointLeft(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the radix
            point moved to the left.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointRight(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointRight(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>A number whose scale is increased by <paramref name='bigPlaces'/>, but not to more than 0.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointRight(System.Int32)">
<summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.MovePointRight(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the radix
            point moved to the right.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Multiply(PeterO.ExtendedFloat)">
<summary>Multiplies two binary floats. The resulting exponent will
            be the sum of the exponents of the two binary floats.</summary>
            <param name='otherValue'>Another binary float.</param>
            <returns>The product of the two binary floats.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Multiply(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Multiplies two binary floats. The resulting scale will be
            the sum of the scales of the two binary floats. The result's sign
            is positive if both operands have the same sign, and negative if
            they have different signs.</summary>
            <param name='op'>Another binary float.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The product of the two binary floats.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MultiplyAndAdd(PeterO.ExtendedFloat,PeterO.ExtendedFloat)">
<summary>Multiplies by one binary float, and then adds another
            binary float.</summary>
            <param name='multiplicand'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <returns>The result this * multiplicand + augend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='multiplicand'/> or <paramref name='augend'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MultiplyAndAdd(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Multiplies by one value, and then adds another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='augend'>The value to add.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The result thisValue * multiplicand + augend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> or <paramref name='augend'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.MultiplyAndSubtract(PeterO.ExtendedFloat,PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Multiplies by one value, and then subtracts another
            value.</summary>
            <param name='op'>The value to multiply.</param>
            <param name='subtrahend'>The value to subtract.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The result thisValue * multiplicand -
            subtrahend.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='op'/> or <paramref name='subtrahend'/> is
            null.</exception>
</doc>
<doc name="F:PeterO.ExtendedFloat.NaN">
<summary>A not-a-number value.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.Negate">
<summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary>
            <returns>An arbitrary-precision binary float.  If this value is positive zero, returns positive zero.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Negate(PeterO.PrecisionContext)">
<summary>Returns a binary float with the same value as this object
            but with the sign reversed.</summary>
            <param name='context'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.  If this value is positive zero, returns positive zero.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='context'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedFloat.NegativeInfinity">
<summary>Negative infinity, less than any other number.</summary>
</doc>
<doc name="F:PeterO.ExtendedFloat.NegativeZero">
<summary>Represents the number negative zero.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.NextMinus(PeterO.PrecisionContext)">
<summary>Finds the largest value that's smaller than the given
            value.</summary>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null, the precision is 0, or <paramref name='ctx'/> has an unlimited exponent range.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.NextPlus(PeterO.PrecisionContext)">
<summary>Finds the smallest value that's greater than the given
            value.</summary>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the smallest value that's greater than the given
            value.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null, the precision is 0, or <paramref name='ctx'/> has an unlimited exponent range.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.NextToward(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Finds the next value that is closer to the other object's
            value than this object's value.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            float.</param>
            <param name='ctx'>A precision context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags).</param>
            <returns>Returns the next value that is closer to the other object'
            s value than this object's value.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null, the precision is 0, or <paramref name='ctx'/> has an unlimited exponent range.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedFloat.One">
<summary>Represents the number 1.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.PI(PeterO.PrecisionContext)">
<summary>Finds the constant &#x3c0;, the circumference of a circle divided by its diameter.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as &#x3c0; can never be represented
            exactly.</i></param>
            <returns>The constant &#x3c0; rounded to the given precision.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Plus(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given precision,
            using the given rounding mode and range of exponent, and also
            converts negative zero to positive zero.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="F:PeterO.ExtendedFloat.PositiveInfinity">
<summary>Positive infinity, greater than any other
            number.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.Pow(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Raises this object's value to the given
            exponent.</summary>
            <param name='exponent'>An arbitrary-precision binary float.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity.</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0), and the exponent has a
            fractional part.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Pow(System.Int32)">
<summary>Raises this object&#x27;s value to the given
            exponent.</summary>
            <param name='exponentSmall'>A 32-bit signed integer.</param>
            <returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Pow(System.Int32,PeterO.PrecisionContext)">
<summary>Raises this object&#x27;s value to the given
            exponent.</summary>
            <param name='exponentSmall'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing
            flags).</param>
            <returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Precision">
<summary>Finds the number of digits in this number's mantissa.
            Returns 1 if this value is 0, and 0 if this value is infinity or
            NaN.</summary>
            <returns>An arbitrary-precision integer.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Quantize(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a binary float with the same value but a new
            exponent.</summary>
            <param name='desiredExponent'>An arbitrary-precision
            integer.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>A binary float with the same value as this object but with
            the exponent changed. Signals FlagInvalid and returns not-a-number
            (NaN) if an overflow error occurred, or the rounded result can't
            fit the given precision, or if the context defines an exponent
            range and the given exponent is outside that range.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='desiredExponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Quantize(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Returns a binary float with the same value as this object
            but with the same exponent as another binary float.</summary>
            <param name='otherValue'>A binary float containing the desired
            exponent of the result. The mantissa is ignored. The exponent is
            the number of fractional digits in the result, expressed as a
            negative number. Can also be positive, which eliminates lower-order
            places from the number. For example, -3 means round to the
            thousandth (10^-3, 0.0001), and 3 means round to the thousand
            (10^3, 1000). A value of 0 rounds the number to an integer.</param>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A binary float with the same value as this object but with
            the exponent changed. Signals FlagInvalid and returns not-a-number
            (NaN) if an overflow error occurred, or the result can't fit the
            given precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the new exponent is outside of the valid
            range of the precision context, if it defines an exponent
            range.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Quantize(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a binary float with the same value but a new
            exponent.</summary>
            <param name='desiredExponentSmall'>A 32-bit signed integer.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>A binary float with the same value as this object but with
            the exponent changed. Signals FlagInvalid and returns not-a-number
            (NaN) if an overflow error occurred, or the rounded result can't
            fit the given precision, or if the context defines an exponent
            range and the given exponent is outside that range.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Reduce(PeterO.PrecisionContext)">
<summary>Removes trailing zeros from this object&#x27;s mantissa.
            For example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the
            mantissa.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Remainder(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Finds the remainder that results when dividing two
            arbitrary-precision binary floats.</summary>
            <param name='divisor'>An arbitrary-precision binary float.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RemainderNaturalScale(PeterO.ExtendedFloat)">
<summary>Calculates the remainder of a number by the formula this -
            ((this / divisor) * divisor).</summary>
            <param name='divisor'>The number to divide by.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RemainderNaturalScale(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Calculates the remainder of a number by the formula this -
            ((this / divisor) * divisor).</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision, rounding, and exponent range of the integer part of the
            result. This context will be used only in the division portion of
            the remainder calculation. Flags will be set on the given context
            only if the context's HasFlags is true and the integer part of the
            division result doesn't fit the precision and exponent range
            without rounding.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RemainderNear(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value by
            another object's value.
            <list type=''>
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor' s absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary>
            <param name='divisor'>The number to divide by.</param>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            HasFlags of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null.</param>
            <returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='divisor'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToBinaryPrecision(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given maximum bit
            length, using the given rounding mode and range of
            exponent.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. The precision is interpreted as the
            maximum bit length of the mantissa. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToExponent(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this
            object but rounded to a new exponent if necessary.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the sixteenth (10b^-3, 0.0001b), and 3 means round
            to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
            to an integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary number rounded to the closest value representable
            in the given precision, meaning if the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the precision context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToExponent(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this
            object but rounded to a new exponent if necessary.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places in the number. For example, -3 means round
            to the sixteenth (10b^-3, 0.0001b), and 3 means round to the
            sixteen-place (10b^3, 1000b). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param>
            <returns>A binary number rounded to the closest value representable
            in the given precision, meaning if the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToExponentExact(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this object
            but rounded to the given exponent, and signals an inexact flag if the
            result would be inexact.</summary>
            <param name='exponent'>The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the sixteenth (10b^-3, 0.0001b), and 3 means round
            to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
            to an integer.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>A binary number rounded to the closest value representable
            in the given precision. Signals FlagInvalid and returns
            not-a-number (NaN) if the result can't fit the given precision
            without rounding. Signals FlagInvalid and returns not-a-number
            (NaN) if the precision context defines an exponent range, the new
            exponent must be changed to the given exponent when rounding, and
            the given exponent is outside of the valid range of the precision
            context.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToExponentExact(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this object
            but rounded to the given exponent, and signals an inexact flag if the
            result would be inexact.</summary>
            <param name='exponentSmall'>The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places in the number. For example, -3 means round
            to the sixteenth (10b^-3, 0.0001b), and 3 means round to the
            sixteen-place (10b^3, 1000b). A value of 0 rounds the number to an
            integer.</param>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>A binary number rounded to the closest value representable
            in the given precision. Signals FlagInvalid and returns
            not-a-number (NaN) if the result can't fit the given precision
            without rounding. Signals FlagInvalid and returns not-a-number
            (NaN) if the precision context defines an exponent range, the new
            exponent must be changed to the given exponent when rounding, and
            the given exponent is outside of the valid range of the precision
            context.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToIntegralExact(PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this object
            but rounded to an integer, and signals an inexact flag if the
            result would be inexact.</summary>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            default rounding mode is HalfEven.</param>
            <returns>A binary number rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the precision context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToIntegralNoRoundedFlag(PeterO.PrecisionContext)">
<summary>Returns a binary number with the same value as this object
            but rounded to an integer, without adding the FlagInexact or
            FlagRounded flags.</summary>
            <param name='ctx'>A precision context to control precision and
            rounding of the result. If HasFlags of the context is true, will
            also store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags), except that this function will
            never add the FlagRounded and FlagInexact flags (the only
            difference between this and RoundToExponentExact). Can be null, in
            which case the default rounding mode is HalfEven.</param>
            <returns>A binary number rounded to the closest integer
            representable in the given precision, meaning if the result can't
            fit the precision, additional digits are discarded to make it fit.
            Signals FlagInvalid and returns not-a-number (NaN) if the precision
            context defines an exponent range, the new exponent must be changed
            to 0 when rounding, and 0 is outside of the valid range of the
            precision context.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.RoundToPrecision(PeterO.PrecisionContext)">
<summary>Rounds this object&#x27;s value to a given precision,
            using the given rounding mode and range of exponent.</summary>
            <param name='ctx'>A context for controlling the precision, rounding
            mode, and exponent range. Can be null.</param>
            <returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name='ctx'/> is null or the precision and exponent range
            are unlimited.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ScaleByPowerOfTwo(PeterO.BigInteger)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.ScaleByPowerOfTwo(PeterO.BigInteger,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with its scale
            adjusted.</summary>
            <param name='bigPlaces'>An arbitrary-precision integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>A number whose scale is increased by <paramref name='bigPlaces'/>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigPlaces'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.ScaleByPowerOfTwo(System.Int32)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ScaleByPowerOfTwo(System.Int32,PeterO.PrecisionContext)">
<summary>Returns a number similar to this number but with the scale
            adjusted.</summary>
            <param name='places'>A 32-bit signed integer.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.Sign">
<summary>Gets this value&#x27;s sign: -1 if negative; 1 if
            positive; 0 if zero.</summary>
            <value>This value&apos;s sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
</doc>
<doc name="F:PeterO.ExtendedFloat.SignalingNaN">
<summary>A not-a-number value that signals an invalid operation
            flag when it&#x27;s passed as an argument to any arithmetic
            operation in arbitrary-precision binary float.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.SquareRoot(PeterO.PrecisionContext)">
<summary>Finds the square root of this object's value.</summary>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter cannot be null, as the square root function's
            results are generally not exact for many inputs.</i></param>
            <returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN).</returns>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='ctx'/> is null or the precision is unlimited (the
            context's Precision property is 0).</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Subtract(PeterO.ExtendedFloat)">
<summary>Subtracts an arbitrary-precision binary float from this
            instance and returns the result..</summary>
            <param name='otherValue'>An arbitrary-precision binary
            float.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.Subtract(PeterO.ExtendedFloat,PeterO.PrecisionContext)">
<summary>Subtracts an arbitrary-precision binary float from this
            instance.</summary>
            <param name='otherValue'>An arbitrary-precision binary
            float.</param>
            <param name='ctx'>A precision context to control precision,
            rounding, and exponent range of the result. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedFloat.Ten">
<summary>Represents the number 10.</summary>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToBigInteger">
<summary>Converts this value to an arbitrary-precision integer. Any
            fractional part of this value will be discarded when converting to
            a big integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToBigIntegerExact">
<summary>Converts this value to an arbitrary-precision integer,
            checking whether the value contains a fractional part.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value
            is not an exact integer.</exception>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToDouble">
<summary>Converts this value to a 64-bit floating-point number. The
            half-even rounding mode is used. <para>If this value is a NaN, sets
            the high bit of the 64-bit floating point number's mantissa for a
            quiet NaN, and clears it for a signaling NaN. Then the next highest
            bit of the mantissa is cleared for a quiet NaN, and set for a
            signaling NaN. Then the other bits of the mantissa are set to the
            lowest bits of this object's unsigned mantissa.</para>
            </summary>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <example>
            The following example converts a number in the form of
            a string to a
            <c>double</c>
            , or a 64-bit floating point number.
            <code>
            public static double StringToDouble(String str) {
            return arbitrary-precision binary float.FromString(str).ToDouble();
            }
            </code>
            </example>
            <example>
            The following example converts a big integer to a
            <c>double</c>
            , or a 64-bit floating point number.
            <code>
            public static double arbitrary-precision integerToDouble(BigInteger
            bigInteger) {
            return arbitrary-precision binary
            float.FromBigInteger(bigInteger).ToDouble();
            }
            </code>
            </example>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToEngineeringString">
<summary>Converts this value to an extended decimal, then returns
            the value of that decimal's ToEngineeringString method.</summary>
            <returns>A text string.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToExtendedDecimal">
<summary>Converts this value to an extended decimal.</summary>
            <returns>An extended decimal with the same value as this extended
            float.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToPlainString">
<summary>Converts this value to a string, but without exponential
            notation.</summary>
            <returns>A text string.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToSingle">
<summary>Converts this value to a 32-bit floating-point number. The
            half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's mantissa for a quiet NaN, and clears it for
            a signaling NaN. Then the next highest bit of the mantissa is
            cleared for a quiet NaN, and set for a signaling NaN. Then the
            other bits of the mantissa are set to the lowest bits of this
            object's unsigned mantissa.</para></summary>
            <returns>The closest 32-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.ToString">
<summary>Converts this value to a string.</summary>
            <returns>A string representation of this object. The value is
            converted to decimal and the decimal form of this number's value is
            returned.</returns>
</doc>
<doc name="M:PeterO.ExtendedFloat.Ulp">
<summary>Returns the unit in the last place. The mantissa will be 1
            and the exponent will be this number's exponent. Returns 1 with an
            exponent of 0 if this number is infinity or NaN.</summary>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="P:PeterO.ExtendedFloat.UnsignedMantissa">
<summary>Gets the absolute value of this object&#x27;s un-scaled
            value.</summary>
            <value>The absolute value of this object&apos;s un-scaled
            value.</value>
</doc>
<doc name="F:PeterO.ExtendedFloat.Zero">
<summary>Represents the number 0.</summary>
</doc>
<doc name="T:PeterO.ExtendedRational">
<summary> <para><b>This class is largely obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.ERational</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET), or <c>com.upokecenter.numbers.ERational</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).  This new class can be used in the <c>CBORObject.FromObject(Object)</c>
            method (by including the new library in your code, among other things), but this version of the CBOR library doesn't
            include any methods that explicitly take an <c>ERational</c> as a parameter
            or return value.</b></para>Arbitrary-precision rational number. This class cannot be
            inherited; this is a change in version 2.0 from previous versions,
            where the class was inadvertently left inheritable.
            <para><b>Thread safety:</b>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which only checks if each side of
            the operator is the same instance).</para></summary>
</doc>
<doc name="M:PeterO.ExtendedRational.#ctor(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Initializes a new instance of the <see cref='T:PeterO.ExtendedRational'/> class.</summary>
            <param name='numerator'>An arbitrary-precision integer.</param>
            <param name='denominator'>Another arbitrary-precision
            integer.</param>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.Abs">
<summary>Finds the absolute value of this rational
            number.</summary>
            <returns>An arbitrary-precision rational number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.Add(PeterO.ExtendedRational)">
<summary>Adds two rational numbers.</summary>
            <param name='otherValue'>Another arbitrary-precision rational
            number.</param>
            <returns>The sum of the two numbers. Returns not-a-number (NaN) if
            either operand is NaN.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.CompareTo(PeterO.ExtendedRational)">
<summary>Compares an arbitrary-precision rational number with this
            instance.</summary>
            <param name='other'>An arbitrary-precision rational number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.CompareToBinary(PeterO.ExtendedFloat)">
<summary>Compares an arbitrary-precision binary float with this
            instance.</summary>
            <param name='other'>An arbitrary-precision binary float.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.CompareToDecimal(PeterO.ExtendedDecimal)">
<summary>Compares an arbitrary-precision decimal number with this
            instance.</summary>
            <param name='other'>An arbitrary-precision decimal number.</param>
            <returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.Create(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Creates a rational number with the given numerator and
            denominator.</summary>
            <param name='numerator'>An arbitrary-precision integer.</param>
            <param name='denominator'>Another arbitrary-precision
            integer.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.Create(System.Int32,System.Int32)">
<summary>Creates a rational number with the given numerator and
            denominator.</summary>
            <param name='numeratorSmall'>A 32-bit signed integer.</param>
            <param name='denominatorSmall'>A 32-bit signed integer.
            (2).</param>
            <returns>An arbitrary-precision rational number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.CreateNaN(PeterO.BigInteger)">
<summary>Creates a not-a-number arbitrary-precision rational
            number.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='diag'/> is less than 0.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.CreateNaN(PeterO.BigInteger,System.Boolean,System.Boolean)">
<summary>Creates a not-a-number arbitrary-precision rational
            number.</summary>
            <param name='diag'>A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param>
            <param name='signaling'>Whether the return value will be signaling
            (true) or quiet (false).</param>
            <param name='negative'>Whether the return value is
            negative.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='diag'/> is null.</exception>
            <exception cref='T:System.ArgumentException'>The parameter
            <paramref name='diag'/> is less than 0.</exception>
</doc>
<doc name="P:PeterO.ExtendedRational.Denominator">
<summary>Gets this object's denominator.</summary>
            <value>This object&apos;s denominator.</value>
</doc>
<doc name="M:PeterO.ExtendedRational.Divide(PeterO.ExtendedRational)">
<summary>Divides this instance by the value of an
            arbitrary-precision rational number object.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.Equals(PeterO.ExtendedRational)">
<summary>Returns whether this object's properties are equal to the properties
of another rational number object.</summary>
            <param name='other'>Another arbitrary-precision rational number.</param>
            <returns><c>true</c> if this object's properties are equal to the properties
of another rational number object; otherwise, <c>false</c>.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.Equals(System.Object)">
<summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>An arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.FromBigInteger(PeterO.BigInteger)">
<summary>Converts a big integer to a rational number.</summary>
            <param name='bigint'>An arbitrary-precision integer.</param>
            <returns>The exact value of the integer as a rational
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.FromDouble(System.Double)">
<summary>Converts a 64-bit floating-point number to a rational
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the number to a string.</summary>
            <param name='flt'>A 64-bit floating-point number.</param>
            <returns>A rational number with the same value as <paramref name='flt'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.FromExtendedDecimal(PeterO.ExtendedDecimal)">
<summary>Converts an arbitrary-precision decimal number to a
            rational number.</summary>
            <param name='ef'>An arbitrary-precision decimal number.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='ef'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.FromExtendedFloat(PeterO.ExtendedFloat)">
<summary>Converts an arbitrary-precision binary float to a
            rational number.</summary>
            <param name='ef'>An arbitrary-precision binary float.</param>
            <returns>An arbitrary-precision rational number.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='ef'/> is null.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.FromInt32(System.Int32)">
<summary>Converts a 32-bit signed integer to a rational number.</summary>
            <param name='smallint'>A 32-bit signed integer.</param>
            <returns>An arbitrary-precision rational number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.FromInt64(System.Int64)">
<summary>Converts a 64-bit signed integer to a rational number.</summary>
            <param name='longInt'>A 64-bit signed integer.</param>
            <returns>An arbitrary-precision rational number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.FromSingle(System.Single)">
<summary>Converts a 32-bit floating-point number to a rational
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the number to a string.</summary>
            <param name='flt'>A 32-bit floating-point number.</param>
            <returns>A rational number with the same value as <paramref name='flt'/>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.GetHashCode">
<summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit hash code.</returns>
</doc>
<doc name="P:PeterO.ExtendedRational.IsFinite">
<summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary>
            <value><c>true</c> if this object is finite (not infinity or NaN);
            otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedRational.IsInfinity">
<summary>Gets a value indicating whether this object's value is
            infinity.</summary>
            <returns><c>true</c> if this object's value is infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.IsNaN">
<summary>Returns whether this object is a not-a-number
            value.</summary>
            <returns><c>true</c> if this object is a not-a-number value; otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedRational.IsNegative">
<summary>Gets a value indicating whether this object's value is
            negative (including negative zero).</summary>
            <value><c>true</c> if this object&apos;s value is negative; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedRational.IsNegativeInfinity">
<summary>Returns whether this object is negative
            infinity.</summary>
            <returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.IsPositiveInfinity">
<summary>Returns whether this object is positive
            infinity.</summary>
            <returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.IsQuietNaN">
<summary>Returns whether this object is a quiet not-a-number
            value.</summary>
            <returns><c>true</c> if this object is a quiet not-a-number value;
            otherwise, <c>false</c>.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.IsSignalingNaN">
<summary>Returns whether this object is a signaling not-a-number
            value (which causes an error if the value is passed to any
            arithmetic operation in this class).</summary>
            <returns><c>true</c> if this object is a signaling not-a-number value
            (which causes an error if the value is passed to any arithmetic
            operation in this class); otherwise, <c>false</c>.</returns>
</doc>
<doc name="P:PeterO.ExtendedRational.IsZero">
<summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object&apos;s value equals 0; otherwise, <c>false</c>.</value>
</doc>
<doc name="M:PeterO.ExtendedRational.Multiply(PeterO.ExtendedRational)">
<summary>Multiplies this instance by the value of an
            arbitrary-precision rational number.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The product of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedRational.NaN">
<summary>A not-a-number value.</summary>
</doc>
<doc name="M:PeterO.ExtendedRational.Negate">
<summary>Finds a rational number with the same value as this object
            but with the sign reversed.</summary>
            <returns>The negated form of this rational number.</returns>
</doc>
<doc name="F:PeterO.ExtendedRational.NegativeInfinity">
<summary>Negative infinity, less than any other number.</summary>
</doc>
<doc name="F:PeterO.ExtendedRational.NegativeZero">
<summary>A rational number for negative zero.</summary>
</doc>
<doc name="P:PeterO.ExtendedRational.Numerator">
<summary>Gets this object's numerator.</summary>
            <value>This object&apos;s numerator. If this object is a
            not-a-number value, returns the diagnostic information (which will
            be negative if this object is negative).</value>
</doc>
<doc name="F:PeterO.ExtendedRational.One">
<summary>The rational number one.</summary>
</doc>
<doc name="F:PeterO.ExtendedRational.PositiveInfinity">
<summary>Positive infinity, greater than any other
            number.</summary>
</doc>
<doc name="M:PeterO.ExtendedRational.Remainder(PeterO.ExtendedRational)">
<summary>Finds the remainder that results when this instance is
            divided by the value of an arbitrary-precision rational
            number.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="P:PeterO.ExtendedRational.Sign">
<summary>Gets the sign of this rational number.</summary>
            <value>Zero if this value is zero or negative zero; -1 if this
            value is less than 0; and 1 if this value is greater than
            0.</value>
</doc>
<doc name="F:PeterO.ExtendedRational.SignalingNaN">
<summary>A signaling not-a-number value.</summary>
</doc>
<doc name="M:PeterO.ExtendedRational.Subtract(PeterO.ExtendedRational)">
<summary>Subtracts an arbitrary-precision rational number from this
            instance.</summary>
            <param name='otherValue'>An arbitrary-precision rational
            number.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>
</doc>
<doc name="F:PeterO.ExtendedRational.Ten">
<summary>The rational number ten.</summary>
</doc>
<doc name="M:PeterO.ExtendedRational.ToBigInteger">
<summary>Converts this value to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            a big integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.ToBigIntegerExact">
<summary>Converts this value to an arbitrary-precision integer,
            checking whether the value is an exact integer.</summary>
            <returns>An arbitrary-precision integer.</returns>
            <exception cref='T:System.OverflowException'>This object's value is
            infinity or NaN.</exception>
            <exception cref='T:System.ArithmeticException'>This object's value
            is not an exact integer.</exception>
</doc>
<doc name="M:PeterO.ExtendedRational.ToDouble">
<summary>Converts this value to a 64-bit floating-point number. The
            half-even rounding mode is used.</summary>
            <returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedDecimal">
<summary>Converts this rational number to a decimal
            number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            decimal expansion.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedDecimal(PeterO.PrecisionContext)">
<summary>Converts this rational number to a decimal number and
            rounds the result to the given precision.</summary>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>An arbitrary-precision decimal.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedDecimalExactIfPossible(PeterO.PrecisionContext)">
<summary>Converts this rational number to a decimal number, but if
            the result would have a nonterminating decimal expansion, rounds
            that result to the given precision.</summary>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. This context will be used only if the exact result
            would have a nonterminating decimal expansion. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case this method is the same as
            ToExtendedDecimal.</param>
            <returns>An arbitrary-precision decimal.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedFloat">
<summary>Converts this rational number to a binary
            number.</summary>
            <returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            binary expansion.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedFloat(PeterO.PrecisionContext)">
<summary>Converts this rational number to a binary number and
            rounds the result to the given precision.</summary>
            <param name='ctx'>A PrecisionContext object.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToExtendedFloatExactIfPossible(PeterO.PrecisionContext)">
<summary>Converts this rational number to a binary number, but if
            the result would have a nonterminating binary expansion, rounds
            that result to the given precision.</summary>
            <param name='ctx'>A precision context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. This context will be used only if the exact result
            would have a nonterminating binary expansion. If HasFlags of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case this method is the same as
            ToExtendedFloat.</param>
            <returns>An arbitrary-precision binary float.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToSingle">
<summary>Converts this value to a 32-bit floating-point number. The
            half-even rounding mode is used.</summary>
            <returns>The closest 32-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
</doc>
<doc name="M:PeterO.ExtendedRational.ToString">
<summary>Converts this object to a text string.</summary>
            <returns>A string representation of this object. The result can be
            Infinity, NaN, or sNaN (with a minus sign before it for negative
            values), or a number of the following form:
            [-]numerator/denominator.</returns>
</doc>
<doc name="P:PeterO.ExtendedRational.UnsignedNumerator">
<summary>Gets this object's numerator with the sign
            removed.</summary>
            <value>This object&apos;s numerator. If this object is a
            not-a-number value, returns the diagnostic information.</value>
</doc>
<doc name="F:PeterO.ExtendedRational.Zero">
<summary>A rational number for zero.</summary>
</doc>
<doc name="T:PeterO.PrecisionContext">
<summary>            <para><b>This class is largely obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.EContext</c> in the <c>PeterO.EContext</c>
            library (in .NET), or <c>com.upokecenter.numbers.EFloat</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).</b></para>Contains parameters for controlling the precision,
            rounding, and exponent range of arbitrary-precision
            numbers.</summary>
</doc>
<doc name="M:PeterO.PrecisionContext.#ctor(System.Int32,PeterO.Rounding,System.Int32,System.Int32,System.Boolean)">
<summary>Initializes a new instance of the <see cref='T:PeterO.PrecisionContext'/> class. HasFlags will be set to
            false.</summary><param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited number of digits.</param><param name='rounding'>The rounding mode to use when a number can't fit the given precision.</param><param name='exponentMinSmall'>The minimum exponent.</param><param name='exponentMaxSmall'>The maximum exponent.</param><param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision (if it isn't zero) while remaining within the exponent range.</param>
</doc>
<doc name="P:PeterO.PrecisionContext.AdjustExponent">
<summary>Gets a value indicating whether the EMax and EMin
            properties refer to the number's Exponent property adjusted to the
            number's precision, or just the number's Exponent property. The
            default value is true, meaning that EMax and EMin refer to the
            adjusted exponent. Setting this value to false (using
            WithAdjustExponent) is useful for modeling floating point
            representations with an integer mantissa and an integer exponent,
            such as Java's BigDecimal.</summary>
            <value><c>true</c> if the EMax and EMin properties refer to the
            number&apos;s Exponent property adjusted to the number&apos;s
            precision, or false if they refer to just the number&apos;s
            Exponent property.</value>
</doc>
<doc name="F:PeterO.PrecisionContext.Basic">
<summary>Basic precision context, 9 digits precision, rounding mode
            half-up, unlimited exponent range. The default rounding mode is
            HalfUp.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.BigDecimalJava">
<summary>Precision context for Java's BigDecimal format. The
            default rounding mode is HalfUp.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Binary128">
<summary>Precision context for the IEEE-754-2008 binary128 format,
            113 bits precision. The default rounding mode is
            HalfEven.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Binary16">
<summary>Precision context for the IEEE-754-2008 binary16 format,
            11 bits precision. The default rounding mode is HalfEven.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Binary32">
<summary>Precision context for the IEEE-754-2008 binary32 format,
            24 bits precision. The default rounding mode is HalfEven.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Binary64">
<summary>Precision context for the IEEE-754-2008 binary64 format,
            53 bits precision. The default rounding mode is HalfEven.</summary>
</doc>
<doc name="P:PeterO.PrecisionContext.ClampNormalExponents">
<summary>Gets a value indicating whether a converted number&#x27;s
            Exponent property will not be higher than EMax + 1 - Precision. If
            a number&#x27;s exponent is higher than that value, but not high
            enough to cause overflow, the exponent is clamped to that value and
            enough zeros are added to the number&#x27;s mantissa to account for
            the adjustment. If HasExponentRange is false, this value is always
            false.</summary>
            <value>If true, a converted number&apos;s Exponent property will
            not be higher than EMax + 1 - Precision.</value>
</doc>
<doc name="F:PeterO.PrecisionContext.CliDecimal">
<summary>Precision context for the Common Language Infrastructure
            (.NET Framework) decimal format, 96 bits precision, and a valid
            exponent range of -28 to 0. The default rounding mode is
            HalfEven.</summary>
</doc>
<doc name="M:PeterO.PrecisionContext.Copy">
<summary>Initializes a new PrecisionContext that is a copy of
            another PrecisionContext.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="F:PeterO.PrecisionContext.Decimal128">
<summary>Precision context for the IEEE-754-2008 decimal128 format.
            The default rounding mode is HalfEven.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Decimal32">
<summary>Precision context for the IEEE-754-2008 decimal32 format.
            The default rounding mode is HalfEven.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.Decimal64">
<summary>Precision context for the IEEE-754-2008 decimal64 format.
            The default rounding mode is HalfEven.</summary>
</doc>
<doc name="P:PeterO.PrecisionContext.EMax">
<summary>Gets the highest exponent possible when a converted number
            is expressed in scientific notation with one digit before the
            decimal point. For example, with a precision of 3 and an EMax of
            100, the maximum value possible is 9.99E + 100. (This is not the
            same as the highest possible Exponent property.) If
            HasExponentRange is false, this value will be 0.</summary>
            <value>The highest exponent possible when a converted number is
            expressed in scientific notation with one digit before the decimal
            point. For example, with a precision of 3 and an EMax of 100, the
            maximum value possible is 9.99E + 100. (This is not the same as the
            highest possible Exponent property.) If HasExponentRange is false,
            this value will be 0.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.EMin">
<summary>Gets the lowest exponent possible when a converted number
            is expressed in scientific notation with one digit before the
            decimal point. For example, with a precision of 3 and an EMin of
            -100, the next value that comes after 0 is 0.001E-100. (If
            AdjustExponent is false, this property specifies the lowest
            possible Exponent property instead.) If HasExponentRange is false,
            this value will be 0.</summary>
            <value>The lowest exponent possible when a converted number is
            expressed in scientific notation with one digit before the decimal
            point.</value>
</doc>
<doc name="M:PeterO.PrecisionContext.ExponentWithinRange(PeterO.BigInteger)">
<summary>Determines whether a number can have the given Exponent
            property under this precision context.</summary>
            <param name='exponent'>An arbitrary-precision integer indicating
            the desired exponent.</param>
            <returns><c>true</c> if a number can have the given Exponent property
            under this precision context; otherwise, <c>false</c>. If this context
            allows unlimited precision, returns true for the exponent EMax and
            any exponent less than EMax.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponent'/> is null.</exception>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagClamped">
<summary>Signals that the exponent was adjusted to fit the exponent
            range.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagDivideByZero">
<summary>Signals a division of a nonzero number by zero.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagInexact">
<summary>Signals that the result was rounded to a different
            mathematical value, but as close as possible to the
            original.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagInvalid">
<summary>Signals an invalid operation.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagLostDigits">
<summary>Signals that an operand was rounded to a different
            mathematical value before an operation.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagOverflow">
<summary>Signals that the result is non-zero and the exponent is
            higher than the highest exponent allowed.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagRounded">
<summary>Signals that the result was rounded to fit the precision;
            either the value or the exponent may have changed from the
            original.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagSubnormal">
<summary>Signals that the result&#x27;s exponent, before rounding,
            is lower than the lowest exponent allowed.</summary>
</doc>
<doc name="F:PeterO.PrecisionContext.FlagUnderflow">
<summary>Signals that the result&#x27;s exponent, before rounding,
            is lower than the lowest exponent allowed, and the result was
            rounded to a different mathematical value, but as close as possible
            to the original.</summary>
</doc>
<doc name="P:PeterO.PrecisionContext.Flags">
<summary>Gets or sets the flags that are set from converting
            numbers according to this precision context. If HasFlags is false,
            this value will be 0. This value is a combination of bit fields. To
            retrieve a particular flag, use the AND operation on the return
            value of this method. For example: <c>(this.Flags &amp;
            PrecisionContext.FlagInexact) != 0</c> returns <c>true</c> if the Inexact
            flag is set.</summary>
            <value>The flags that are set from converting numbers according to
            this precision context. If HasFlags is false, this value will be
            0.</value>
</doc>
<doc name="M:PeterO.PrecisionContext.ForPrecision(System.Int32)">
<summary>Creates a new precision context using the given maximum
            number of digits, an unlimited exponent range, and the HalfUp
            rounding mode.</summary>
            <param name='precision'>Maximum number of digits
            (precision).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.ForPrecisionAndRounding(System.Int32,PeterO.Rounding)">
<summary>Creates a new PrecisionContext object initialized with an
            unlimited exponent range, and the given rounding mode and maximum
            precision.</summary>
            <param name='precision'>Maximum number of digits
            (precision).</param>
            <param name='rounding'>An ERounding object.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.ForRounding(PeterO.Rounding)">
<summary>Creates a new PrecisionContext object initialized with an
            unlimited precision, an unlimited exponent range, and the given
            rounding mode.</summary>
            <param name='rounding'>The rounding mode for the new precision
            context.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="P:PeterO.PrecisionContext.HasExponentRange">
<summary>Gets a value indicating whether this context defines a
            minimum and maximum exponent. If false, converted exponents can
            have any exponent and operations can't cause overflow or
            underflow.</summary>
            <value><c>true</c> if this context defines a minimum and maximum exponent;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.HasFlags">
<summary>Gets a value indicating whether this context has a mutable
            Flags field.</summary>
            <value><c>true</c> if this context has a mutable Flags field; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.HasMaxPrecision">
<summary>Gets a value indicating whether this context defines a
            maximum precision.</summary>
            <value><c>true</c> if this context defines a maximum precision; otherwise, <c>false</c>.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.IsPrecisionInBits">
<summary>Gets a value indicating whether this context's Precision
            property is in bits, rather than digits. The default is
            false.</summary>
            <value><c>true</c> if this context&apos;s Precision property is in bits,
            rather than digits; otherwise, <c>false</c>. The default is false.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.IsSimplified">
<summary>Gets a value indicating whether to use a "simplified"
            arithmetic. In the simplified arithmetic, infinity, not-a-number,
            and subnormal numbers are not allowed, and negative zero is treated
            the same as positive zero. For further details, see
            <a href='http://speleotrove.com/decimal/dax3274.html'><c>http://speleotrove.com/decimal/dax3274.html</c></a></summary>
            <value><c>true</c> if a &quot;simplified&quot; arithmetic will be used;
            otherwise, <c>false</c>.</value>
</doc>
<doc name="F:PeterO.PrecisionContext.JavaBigDecimal">
<summary>Precision context for Java's BigDecimal format. The
            default rounding mode is HalfUp.</summary>
</doc>
<doc name="P:PeterO.PrecisionContext.Precision">
<summary>Gets the maximum length of a converted number in digits,
            ignoring the decimal point and exponent. For example, if precision
            is 3, a converted number&#x27;s mantissa can range from 0 to 999
            (up to three digits long). If 0, converted numbers can have any
            precision.</summary>
            <value>The maximum length of a converted number in digits, ignoring
            the decimal point and exponent.</value>
</doc>
<doc name="P:PeterO.PrecisionContext.Rounding">
<summary>Gets the desired rounding mode when converting numbers
            that can&#x27;t be represented in the given precision and exponent
            range.</summary>
            <value>The desired rounding mode when converting numbers that
            can&apos;t be represented in the given precision and exponent
            range.</value>
</doc>
<doc name="M:PeterO.PrecisionContext.ToString">
<summary>Gets a string representation of this object. Note that the
            format is not intended to be parsed and may change at any
            time.</summary>
            <returns>A string representation of this object.</returns>
</doc>
<doc name="P:PeterO.PrecisionContext.Traps">
<summary>Gets the traps that are set for each flag in the context.
            Whenever a flag is signaled, even if HasFlags is false, and the
            flag's trap is enabled, the operation will throw a TrapException.
            <para>For example, if Traps equals FlagInexact and FlagSubnormal, a
            TrapException will be thrown if an operation's return value is not
            the same as the exact result (FlagInexact) or if the return value's
            exponent is lower than the lowest allowed
            (FlagSubnormal).</para></summary>
            <value>The traps that are set for each flag in the context.</value>
</doc>
<doc name="F:PeterO.PrecisionContext.Unlimited">
<summary>No specific limit on precision. Rounding mode
            HalfUp.</summary>
</doc>
<doc name="M:PeterO.PrecisionContext.WithAdjustExponent(System.Boolean)">
<summary>Copies this PrecisionContext and sets the copy's
            "AdjustExponent" property to the given value.</summary><param name='adjustExponent'>The new value of the "AdjustExponent" property for the copy.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithBigExponentRange(PeterO.BigInteger,PeterO.BigInteger)">
<summary>Copies this precision context and sets the copy's exponent
            range.</summary>
            <param name='exponentMin'>Desired minimum exponent (EMin).</param>
            <param name='exponentMax'>Desired maximum exponent (EMax).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponentMin'/> is null.</exception>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='exponentMax'/> is null.</exception>
</doc>
<doc name="M:PeterO.PrecisionContext.WithBigPrecision(PeterO.BigInteger)">
<summary>Copies this PrecisionContext and gives it a particular
            precision value.</summary>
            <param name='bigintPrecision'>Desired maximum number of digits a number can have.
            If 0, the number of digits is unlimited.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
            <exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintPrecision'/> is null.</exception>
</doc>
<doc name="M:PeterO.PrecisionContext.WithBlankFlags">
<summary>Copies this PrecisionContext with HasFlags set to true and
            a Flags value of 0.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithExponentClamp(System.Boolean)">
<summary>Copies this precision context and sets the copy&#x27;s
            &#x22;ClampNormalExponents&#x22; flag to the given value.</summary>
            <param name='clamp'>Desired value for ClampNormalExponents.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithExponentRange(System.Int32,System.Int32)">
<summary>Copies this precision context and sets the copy&#x27;s
            exponent range.</summary>
            <param name='exponentMinSmall'>Desired minimum exponent
            (EMin).</param>
            <param name='exponentMaxSmall'>Desired maximum exponent
            (EMax).</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithNoFlags">
<summary>Copies this PrecisionContext with HasFlags set to false
            and a Flags value of 0.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithPrecision(System.Int32)">
<summary>Copies this PrecisionContext and gives it a particular
            precision value.</summary>
            <param name='precision'>Desired maximum number of digits a number can have.
            If 0, the number of digits is unlimited.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithPrecisionInBits(System.Boolean)">
<summary>Copies this PrecisionContext and sets the copy's
            "IsPrecisionInBits" property to the given value.</summary><param name='isPrecisionBits'>The new value of the "IsPrecisionInBits" property for the copy.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithRounding(PeterO.Rounding)">
<summary>Copies this PrecisionContext with the specified rounding
            mode.</summary>
            <param name='rounding'>Desired value of the Rounding property.</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithSimplified(System.Boolean)">
<summary>Copies this PrecisionContext and sets the copy's
            "IsSimplified" property to the given value.</summary><param name='simplified'>The new value of the "IsSimplified" property for the copy.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithTraps(System.Int32)">
<summary>Copies this PrecisionContext with Traps set to the given
            value.</summary>
            <param name='traps'>Flags representing the traps to enable. See the
            property "Traps".</param>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="M:PeterO.PrecisionContext.WithUnlimitedExponents">
<summary>Copies this PrecisionContext with an unlimited exponent
            range.</summary>
            <returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
</doc>
<doc name="T:PeterO.Rounding">
<summary>            <para><b>This class is obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.ERounding</c> in the <c>PeterO.ERounding</c>
            library (in .NET), or <c>com.upokecenter.numbers.EFloat</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).</b></para>Specifies the mode to use when &#x22;shortening&#x22;
            numbers that otherwise can&#x27;t fit a given number of digits, so
            that the shortened number has about the same value. This
            &#x22;shortening&#x22; is known as rounding.</summary>
</doc>
<doc name="F:PeterO.Rounding.Ceiling">
<summary>If there is a fractional part, the number is rounded to
            the highest representable number that&#x27;s closest to
            it.</summary>
</doc>
<doc name="F:PeterO.Rounding.Down">
<summary>The fractional part is discarded (the number is
            truncated).</summary>
</doc>
<doc name="F:PeterO.Rounding.Floor">
<summary>If there is a fractional part, the number is rounded to
            the lowest representable number that&#x27;s closest to
            it.</summary>
</doc>
<doc name="F:PeterO.Rounding.HalfDown">
<summary>Rounded to the nearest number; if the fractional part is
            exactly half, it is discarded.</summary>
</doc>
<doc name="F:PeterO.Rounding.HalfEven">
<summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number that is even. This is sometimes also known as
            &#x22;banker&#x27;s rounding&#x22;.</summary>
</doc>
<doc name="F:PeterO.Rounding.HalfUp">
<summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number away from zero. This is the most familiar rounding mode for
            many people.</summary>
</doc>
<doc name="F:PeterO.Rounding.Odd">
<summary>If there is a fractional part and the whole number part is
            even, the number is rounded to the closest representable odd number
            away from zero.</summary>
</doc>
<doc name="F:PeterO.Rounding.OddOrZeroFiveUp">
<summary>For binary floating point numbers, this is the same as
            Odd. For other bases (including decimal numbers), this is the same
            as ZeroFiveUp. This rounding mode is useful for rounding
            intermediate results at a slightly higher precision (at least 2
            bits more for binary) than the final precision.</summary>
</doc>
<doc name="F:PeterO.Rounding.Unnecessary">
<summary>Indicates that rounding will not be used. If rounding is
            required, the rounding operation will report an error.</summary>
</doc>
<doc name="F:PeterO.Rounding.Up">
<summary>If there is a fractional part, the number is rounded to
            the closest representable number away from zero.</summary>
</doc>
<doc name="F:PeterO.Rounding.ZeroFiveUp">
<summary>If there is a fractional part and if the last digit before
            rounding is 0 or half the radix, the number is rounded to the
            closest representable number away from zero; otherwise the
            fractional part is discarded. In overflow, the fractional part is
            always discarded.</summary>
</doc>
<doc name="T:PeterO.TrapException">
<summary>            <para><b>This class is obsolete. It will be replaced by a new
            version of this class in a different namespace/package and library,
            called <c>PeterO.Numbers.ETrapException</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
            library (in .NET), or <c>com.upokecenter.numbers.ETrapException</c> in the 
            <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
            artifact (in Java).</b></para>
            Exception thrown for arithmetic trap errors.</summary>
</doc>
<doc name="M:PeterO.TrapException.#ctor(System.Int32,PeterO.PrecisionContext,System.Object)">
<summary>Initializes a new instance of the <see cref='T:PeterO.TrapException'/> class.</summary>
            <param name='flag'>A flag that specifies the kind of error
            (PrecisionContext.FlagXXX). This will only be one flag, such as
            FlagInexact or FlagSubnormal.</param>
            <param name='ctx'>A context object for arbitrary-precision
            arithmetic settings.</param>
            <param name='result'>The desired result of the operation that
            caused the trap, such as an <c>ExtendedDecimal</c> or
            <c>ExtendedFloat</c>.</param>
</doc>
<doc name="P:PeterO.TrapException.Context">
<summary>Gets the precision context used during the operation that
            triggered the trap. May be null.</summary>
            <value>The precision context used during the operation that
            triggered the trap. May be null.</value>
</doc>
<doc name="P:PeterO.TrapException.Error">
<summary>Gets the flag that specifies the kind of error
            (PrecisionContext.FlagXXX). This will only be one flag, such as
            FlagInexact or FlagSubnormal.</summary>
            <value>The flag that specifies the kind of error
            (PrecisionContext.FlagXXX). This will only be one flag, such as
            FlagInexact or FlagSubnormal.</value>
</doc>
<doc name="P:PeterO.TrapException.Result">
<summary>Gets the defined result of the operation that caused the
            trap.</summary>
            <value>The defined result of the operation that caused the
            trap.</value>
</doc>
</docs>
